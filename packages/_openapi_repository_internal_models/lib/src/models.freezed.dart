// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'models.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

RepositoryTemplateModel _$RepositoryTemplateModelFromJson(
    Map<String, dynamic> json) {
  return _RepositoryTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$RepositoryTemplateModel {
  String get repositoryName => throw _privateConstructorUsedError;
  String get buildForClass => throw _privateConstructorUsedError;
  String get baseUrl => throw _privateConstructorUsedError;
  String get liveBasePath => throw _privateConstructorUsedError;
  List<AccessorModel> get accessors => throw _privateConstructorUsedError;
  int get connectTimeout => throw _privateConstructorUsedError;
  int get receiveTimeout => throw _privateConstructorUsedError;
  int get sendTimeout => throw _privateConstructorUsedError;

  /// Serializes this RepositoryTemplateModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of RepositoryTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $RepositoryTemplateModelCopyWith<RepositoryTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RepositoryTemplateModelCopyWith<$Res> {
  factory $RepositoryTemplateModelCopyWith(RepositoryTemplateModel value,
          $Res Function(RepositoryTemplateModel) then) =
      _$RepositoryTemplateModelCopyWithImpl<$Res, RepositoryTemplateModel>;
  @useResult
  $Res call(
      {String repositoryName,
      String buildForClass,
      String baseUrl,
      String liveBasePath,
      List<AccessorModel> accessors,
      int connectTimeout,
      int receiveTimeout,
      int sendTimeout});
}

/// @nodoc
class _$RepositoryTemplateModelCopyWithImpl<$Res,
        $Val extends RepositoryTemplateModel>
    implements $RepositoryTemplateModelCopyWith<$Res> {
  _$RepositoryTemplateModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of RepositoryTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? repositoryName = null,
    Object? buildForClass = null,
    Object? baseUrl = null,
    Object? liveBasePath = null,
    Object? accessors = null,
    Object? connectTimeout = null,
    Object? receiveTimeout = null,
    Object? sendTimeout = null,
  }) {
    return _then(_value.copyWith(
      repositoryName: null == repositoryName
          ? _value.repositoryName
          : repositoryName // ignore: cast_nullable_to_non_nullable
              as String,
      buildForClass: null == buildForClass
          ? _value.buildForClass
          : buildForClass // ignore: cast_nullable_to_non_nullable
              as String,
      baseUrl: null == baseUrl
          ? _value.baseUrl
          : baseUrl // ignore: cast_nullable_to_non_nullable
              as String,
      liveBasePath: null == liveBasePath
          ? _value.liveBasePath
          : liveBasePath // ignore: cast_nullable_to_non_nullable
              as String,
      accessors: null == accessors
          ? _value.accessors
          : accessors // ignore: cast_nullable_to_non_nullable
              as List<AccessorModel>,
      connectTimeout: null == connectTimeout
          ? _value.connectTimeout
          : connectTimeout // ignore: cast_nullable_to_non_nullable
              as int,
      receiveTimeout: null == receiveTimeout
          ? _value.receiveTimeout
          : receiveTimeout // ignore: cast_nullable_to_non_nullable
              as int,
      sendTimeout: null == sendTimeout
          ? _value.sendTimeout
          : sendTimeout // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RepositoryTemplateModelImplCopyWith<$Res>
    implements $RepositoryTemplateModelCopyWith<$Res> {
  factory _$$RepositoryTemplateModelImplCopyWith(
          _$RepositoryTemplateModelImpl value,
          $Res Function(_$RepositoryTemplateModelImpl) then) =
      __$$RepositoryTemplateModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String repositoryName,
      String buildForClass,
      String baseUrl,
      String liveBasePath,
      List<AccessorModel> accessors,
      int connectTimeout,
      int receiveTimeout,
      int sendTimeout});
}

/// @nodoc
class __$$RepositoryTemplateModelImplCopyWithImpl<$Res>
    extends _$RepositoryTemplateModelCopyWithImpl<$Res,
        _$RepositoryTemplateModelImpl>
    implements _$$RepositoryTemplateModelImplCopyWith<$Res> {
  __$$RepositoryTemplateModelImplCopyWithImpl(
      _$RepositoryTemplateModelImpl _value,
      $Res Function(_$RepositoryTemplateModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of RepositoryTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? repositoryName = null,
    Object? buildForClass = null,
    Object? baseUrl = null,
    Object? liveBasePath = null,
    Object? accessors = null,
    Object? connectTimeout = null,
    Object? receiveTimeout = null,
    Object? sendTimeout = null,
  }) {
    return _then(_$RepositoryTemplateModelImpl(
      repositoryName: null == repositoryName
          ? _value.repositoryName
          : repositoryName // ignore: cast_nullable_to_non_nullable
              as String,
      buildForClass: null == buildForClass
          ? _value.buildForClass
          : buildForClass // ignore: cast_nullable_to_non_nullable
              as String,
      baseUrl: null == baseUrl
          ? _value.baseUrl
          : baseUrl // ignore: cast_nullable_to_non_nullable
              as String,
      liveBasePath: null == liveBasePath
          ? _value.liveBasePath
          : liveBasePath // ignore: cast_nullable_to_non_nullable
              as String,
      accessors: null == accessors
          ? _value._accessors
          : accessors // ignore: cast_nullable_to_non_nullable
              as List<AccessorModel>,
      connectTimeout: null == connectTimeout
          ? _value.connectTimeout
          : connectTimeout // ignore: cast_nullable_to_non_nullable
              as int,
      receiveTimeout: null == receiveTimeout
          ? _value.receiveTimeout
          : receiveTimeout // ignore: cast_nullable_to_non_nullable
              as int,
      sendTimeout: null == sendTimeout
          ? _value.sendTimeout
          : sendTimeout // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$RepositoryTemplateModelImpl implements _RepositoryTemplateModel {
  const _$RepositoryTemplateModelImpl(
      {required this.repositoryName,
      required this.buildForClass,
      required this.baseUrl,
      required this.liveBasePath,
      final List<AccessorModel> accessors = const [],
      required this.connectTimeout,
      required this.receiveTimeout,
      required this.sendTimeout})
      : _accessors = accessors;

  factory _$RepositoryTemplateModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$RepositoryTemplateModelImplFromJson(json);

  @override
  final String repositoryName;
  @override
  final String buildForClass;
  @override
  final String baseUrl;
  @override
  final String liveBasePath;
  final List<AccessorModel> _accessors;
  @override
  @JsonKey()
  List<AccessorModel> get accessors {
    if (_accessors is EqualUnmodifiableListView) return _accessors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_accessors);
  }

  @override
  final int connectTimeout;
  @override
  final int receiveTimeout;
  @override
  final int sendTimeout;

  @override
  String toString() {
    return 'RepositoryTemplateModel(repositoryName: $repositoryName, buildForClass: $buildForClass, baseUrl: $baseUrl, liveBasePath: $liveBasePath, accessors: $accessors, connectTimeout: $connectTimeout, receiveTimeout: $receiveTimeout, sendTimeout: $sendTimeout)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RepositoryTemplateModelImpl &&
            (identical(other.repositoryName, repositoryName) ||
                other.repositoryName == repositoryName) &&
            (identical(other.buildForClass, buildForClass) ||
                other.buildForClass == buildForClass) &&
            (identical(other.baseUrl, baseUrl) || other.baseUrl == baseUrl) &&
            (identical(other.liveBasePath, liveBasePath) ||
                other.liveBasePath == liveBasePath) &&
            const DeepCollectionEquality()
                .equals(other._accessors, _accessors) &&
            (identical(other.connectTimeout, connectTimeout) ||
                other.connectTimeout == connectTimeout) &&
            (identical(other.receiveTimeout, receiveTimeout) ||
                other.receiveTimeout == receiveTimeout) &&
            (identical(other.sendTimeout, sendTimeout) ||
                other.sendTimeout == sendTimeout));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      repositoryName,
      buildForClass,
      baseUrl,
      liveBasePath,
      const DeepCollectionEquality().hash(_accessors),
      connectTimeout,
      receiveTimeout,
      sendTimeout);

  /// Create a copy of RepositoryTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RepositoryTemplateModelImplCopyWith<_$RepositoryTemplateModelImpl>
      get copyWith => __$$RepositoryTemplateModelImplCopyWithImpl<
          _$RepositoryTemplateModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RepositoryTemplateModelImplToJson(
      this,
    );
  }
}

abstract class _RepositoryTemplateModel implements RepositoryTemplateModel {
  const factory _RepositoryTemplateModel(
      {required final String repositoryName,
      required final String buildForClass,
      required final String baseUrl,
      required final String liveBasePath,
      final List<AccessorModel> accessors,
      required final int connectTimeout,
      required final int receiveTimeout,
      required final int sendTimeout}) = _$RepositoryTemplateModelImpl;

  factory _RepositoryTemplateModel.fromJson(Map<String, dynamic> json) =
      _$RepositoryTemplateModelImpl.fromJson;

  @override
  String get repositoryName;
  @override
  String get buildForClass;
  @override
  String get baseUrl;
  @override
  String get liveBasePath;
  @override
  List<AccessorModel> get accessors;
  @override
  int get connectTimeout;
  @override
  int get receiveTimeout;
  @override
  int get sendTimeout;

  /// Create a copy of RepositoryTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RepositoryTemplateModelImplCopyWith<_$RepositoryTemplateModelImpl>
      get copyWith => throw _privateConstructorUsedError;
}

AccessorModel _$AccessorModelFromJson(Map<String, dynamic> json) {
  return _AccessorModel.fromJson(json);
}

/// @nodoc
mixin _$AccessorModel {
  String get type => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get methodName => throw _privateConstructorUsedError;

  /// Serializes this AccessorModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AccessorModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AccessorModelCopyWith<AccessorModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccessorModelCopyWith<$Res> {
  factory $AccessorModelCopyWith(
          AccessorModel value, $Res Function(AccessorModel) then) =
      _$AccessorModelCopyWithImpl<$Res, AccessorModel>;
  @useResult
  $Res call({String type, String name, String methodName});
}

/// @nodoc
class _$AccessorModelCopyWithImpl<$Res, $Val extends AccessorModel>
    implements $AccessorModelCopyWith<$Res> {
  _$AccessorModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AccessorModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? name = null,
    Object? methodName = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      methodName: null == methodName
          ? _value.methodName
          : methodName // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AccessorModelImplCopyWith<$Res>
    implements $AccessorModelCopyWith<$Res> {
  factory _$$AccessorModelImplCopyWith(
          _$AccessorModelImpl value, $Res Function(_$AccessorModelImpl) then) =
      __$$AccessorModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String type, String name, String methodName});
}

/// @nodoc
class __$$AccessorModelImplCopyWithImpl<$Res>
    extends _$AccessorModelCopyWithImpl<$Res, _$AccessorModelImpl>
    implements _$$AccessorModelImplCopyWith<$Res> {
  __$$AccessorModelImplCopyWithImpl(
      _$AccessorModelImpl _value, $Res Function(_$AccessorModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of AccessorModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? name = null,
    Object? methodName = null,
  }) {
    return _then(_$AccessorModelImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      methodName: null == methodName
          ? _value.methodName
          : methodName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AccessorModelImpl implements _AccessorModel {
  const _$AccessorModelImpl(
      {required this.type, required this.name, required this.methodName});

  factory _$AccessorModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$AccessorModelImplFromJson(json);

  @override
  final String type;
  @override
  final String name;
  @override
  final String methodName;

  @override
  String toString() {
    return 'AccessorModel(type: $type, name: $name, methodName: $methodName)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccessorModelImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.methodName, methodName) ||
                other.methodName == methodName));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, name, methodName);

  /// Create a copy of AccessorModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AccessorModelImplCopyWith<_$AccessorModelImpl> get copyWith =>
      __$$AccessorModelImplCopyWithImpl<_$AccessorModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AccessorModelImplToJson(
      this,
    );
  }
}

abstract class _AccessorModel implements AccessorModel {
  const factory _AccessorModel(
      {required final String type,
      required final String name,
      required final String methodName}) = _$AccessorModelImpl;

  factory _AccessorModel.fromJson(Map<String, dynamic> json) =
      _$AccessorModelImpl.fromJson;

  @override
  String get type;
  @override
  String get name;
  @override
  String get methodName;

  /// Create a copy of AccessorModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AccessorModelImplCopyWith<_$AccessorModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

FreezedTemplateModel _$FreezedTemplateModelFromJson(Map<String, dynamic> json) {
  return _FreezedTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$FreezedTemplateModel {
  String get name => throw _privateConstructorUsedError;
  bool get isPaginated => throw _privateConstructorUsedError;
  List<TypeModel> get types => throw _privateConstructorUsedError;
  List<AnnotationModel> get annotations => throw _privateConstructorUsedError;
  bool get isTypesEmpty => throw _privateConstructorUsedError;

  /// Serializes this FreezedTemplateModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of FreezedTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FreezedTemplateModelCopyWith<FreezedTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FreezedTemplateModelCopyWith<$Res> {
  factory $FreezedTemplateModelCopyWith(FreezedTemplateModel value,
          $Res Function(FreezedTemplateModel) then) =
      _$FreezedTemplateModelCopyWithImpl<$Res, FreezedTemplateModel>;
  @useResult
  $Res call(
      {String name,
      bool isPaginated,
      List<TypeModel> types,
      List<AnnotationModel> annotations,
      bool isTypesEmpty});
}

/// @nodoc
class _$FreezedTemplateModelCopyWithImpl<$Res,
        $Val extends FreezedTemplateModel>
    implements $FreezedTemplateModelCopyWith<$Res> {
  _$FreezedTemplateModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of FreezedTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? isPaginated = null,
    Object? types = null,
    Object? annotations = null,
    Object? isTypesEmpty = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      isPaginated: null == isPaginated
          ? _value.isPaginated
          : isPaginated // ignore: cast_nullable_to_non_nullable
              as bool,
      types: null == types
          ? _value.types
          : types // ignore: cast_nullable_to_non_nullable
              as List<TypeModel>,
      annotations: null == annotations
          ? _value.annotations
          : annotations // ignore: cast_nullable_to_non_nullable
              as List<AnnotationModel>,
      isTypesEmpty: null == isTypesEmpty
          ? _value.isTypesEmpty
          : isTypesEmpty // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FreezedTemplateModelImplCopyWith<$Res>
    implements $FreezedTemplateModelCopyWith<$Res> {
  factory _$$FreezedTemplateModelImplCopyWith(_$FreezedTemplateModelImpl value,
          $Res Function(_$FreezedTemplateModelImpl) then) =
      __$$FreezedTemplateModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String name,
      bool isPaginated,
      List<TypeModel> types,
      List<AnnotationModel> annotations,
      bool isTypesEmpty});
}

/// @nodoc
class __$$FreezedTemplateModelImplCopyWithImpl<$Res>
    extends _$FreezedTemplateModelCopyWithImpl<$Res, _$FreezedTemplateModelImpl>
    implements _$$FreezedTemplateModelImplCopyWith<$Res> {
  __$$FreezedTemplateModelImplCopyWithImpl(_$FreezedTemplateModelImpl _value,
      $Res Function(_$FreezedTemplateModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of FreezedTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? isPaginated = null,
    Object? types = null,
    Object? annotations = null,
    Object? isTypesEmpty = null,
  }) {
    return _then(_$FreezedTemplateModelImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      isPaginated: null == isPaginated
          ? _value.isPaginated
          : isPaginated // ignore: cast_nullable_to_non_nullable
              as bool,
      types: null == types
          ? _value._types
          : types // ignore: cast_nullable_to_non_nullable
              as List<TypeModel>,
      annotations: null == annotations
          ? _value._annotations
          : annotations // ignore: cast_nullable_to_non_nullable
              as List<AnnotationModel>,
      isTypesEmpty: null == isTypesEmpty
          ? _value.isTypesEmpty
          : isTypesEmpty // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$FreezedTemplateModelImpl implements _FreezedTemplateModel {
  const _$FreezedTemplateModelImpl(
      {required this.name,
      this.isPaginated = true,
      final List<TypeModel> types = const [],
      final List<AnnotationModel> annotations = const [],
      this.isTypesEmpty = false})
      : _types = types,
        _annotations = annotations;

  factory _$FreezedTemplateModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$FreezedTemplateModelImplFromJson(json);

  @override
  final String name;
  @override
  @JsonKey()
  final bool isPaginated;
  final List<TypeModel> _types;
  @override
  @JsonKey()
  List<TypeModel> get types {
    if (_types is EqualUnmodifiableListView) return _types;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_types);
  }

  final List<AnnotationModel> _annotations;
  @override
  @JsonKey()
  List<AnnotationModel> get annotations {
    if (_annotations is EqualUnmodifiableListView) return _annotations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_annotations);
  }

  @override
  @JsonKey()
  final bool isTypesEmpty;

  @override
  String toString() {
    return 'FreezedTemplateModel(name: $name, isPaginated: $isPaginated, types: $types, annotations: $annotations, isTypesEmpty: $isTypesEmpty)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FreezedTemplateModelImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.isPaginated, isPaginated) ||
                other.isPaginated == isPaginated) &&
            const DeepCollectionEquality().equals(other._types, _types) &&
            const DeepCollectionEquality()
                .equals(other._annotations, _annotations) &&
            (identical(other.isTypesEmpty, isTypesEmpty) ||
                other.isTypesEmpty == isTypesEmpty));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      name,
      isPaginated,
      const DeepCollectionEquality().hash(_types),
      const DeepCollectionEquality().hash(_annotations),
      isTypesEmpty);

  /// Create a copy of FreezedTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FreezedTemplateModelImplCopyWith<_$FreezedTemplateModelImpl>
      get copyWith =>
          __$$FreezedTemplateModelImplCopyWithImpl<_$FreezedTemplateModelImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FreezedTemplateModelImplToJson(
      this,
    );
  }
}

abstract class _FreezedTemplateModel implements FreezedTemplateModel {
  const factory _FreezedTemplateModel(
      {required final String name,
      final bool isPaginated,
      final List<TypeModel> types,
      final List<AnnotationModel> annotations,
      final bool isTypesEmpty}) = _$FreezedTemplateModelImpl;

  factory _FreezedTemplateModel.fromJson(Map<String, dynamic> json) =
      _$FreezedTemplateModelImpl.fromJson;

  @override
  String get name;
  @override
  bool get isPaginated;
  @override
  List<TypeModel> get types;
  @override
  List<AnnotationModel> get annotations;
  @override
  bool get isTypesEmpty;

  /// Create a copy of FreezedTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FreezedTemplateModelImplCopyWith<_$FreezedTemplateModelImpl>
      get copyWith => throw _privateConstructorUsedError;
}

TypeModel _$TypeModelFromJson(Map<String, dynamic> json) {
  return _TypeModel.fromJson(json);
}

/// @nodoc
mixin _$TypeModel {
  bool get isRequired => throw _privateConstructorUsedError;
  bool get isNullable => throw _privateConstructorUsedError;
  String? get defaultValue => throw _privateConstructorUsedError;
  String get type => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;

  /// Serializes this TypeModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of TypeModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $TypeModelCopyWith<TypeModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TypeModelCopyWith<$Res> {
  factory $TypeModelCopyWith(TypeModel value, $Res Function(TypeModel) then) =
      _$TypeModelCopyWithImpl<$Res, TypeModel>;
  @useResult
  $Res call(
      {bool isRequired,
      bool isNullable,
      String? defaultValue,
      String type,
      String name});
}

/// @nodoc
class _$TypeModelCopyWithImpl<$Res, $Val extends TypeModel>
    implements $TypeModelCopyWith<$Res> {
  _$TypeModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of TypeModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isRequired = null,
    Object? isNullable = null,
    Object? defaultValue = freezed,
    Object? type = null,
    Object? name = null,
  }) {
    return _then(_value.copyWith(
      isRequired: null == isRequired
          ? _value.isRequired
          : isRequired // ignore: cast_nullable_to_non_nullable
              as bool,
      isNullable: null == isNullable
          ? _value.isNullable
          : isNullable // ignore: cast_nullable_to_non_nullable
              as bool,
      defaultValue: freezed == defaultValue
          ? _value.defaultValue
          : defaultValue // ignore: cast_nullable_to_non_nullable
              as String?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TypeModelImplCopyWith<$Res>
    implements $TypeModelCopyWith<$Res> {
  factory _$$TypeModelImplCopyWith(
          _$TypeModelImpl value, $Res Function(_$TypeModelImpl) then) =
      __$$TypeModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool isRequired,
      bool isNullable,
      String? defaultValue,
      String type,
      String name});
}

/// @nodoc
class __$$TypeModelImplCopyWithImpl<$Res>
    extends _$TypeModelCopyWithImpl<$Res, _$TypeModelImpl>
    implements _$$TypeModelImplCopyWith<$Res> {
  __$$TypeModelImplCopyWithImpl(
      _$TypeModelImpl _value, $Res Function(_$TypeModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of TypeModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isRequired = null,
    Object? isNullable = null,
    Object? defaultValue = freezed,
    Object? type = null,
    Object? name = null,
  }) {
    return _then(_$TypeModelImpl(
      isRequired: null == isRequired
          ? _value.isRequired
          : isRequired // ignore: cast_nullable_to_non_nullable
              as bool,
      isNullable: null == isNullable
          ? _value.isNullable
          : isNullable // ignore: cast_nullable_to_non_nullable
              as bool,
      defaultValue: freezed == defaultValue
          ? _value.defaultValue
          : defaultValue // ignore: cast_nullable_to_non_nullable
              as String?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TypeModelImpl implements _TypeModel {
  const _$TypeModelImpl(
      {required this.isRequired,
      required this.isNullable,
      this.defaultValue,
      required this.type,
      required this.name});

  factory _$TypeModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$TypeModelImplFromJson(json);

  @override
  final bool isRequired;
  @override
  final bool isNullable;
  @override
  final String? defaultValue;
  @override
  final String type;
  @override
  final String name;

  @override
  String toString() {
    return 'TypeModel(isRequired: $isRequired, isNullable: $isNullable, defaultValue: $defaultValue, type: $type, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TypeModelImpl &&
            (identical(other.isRequired, isRequired) ||
                other.isRequired == isRequired) &&
            (identical(other.isNullable, isNullable) ||
                other.isNullable == isNullable) &&
            (identical(other.defaultValue, defaultValue) ||
                other.defaultValue == defaultValue) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, isRequired, isNullable, defaultValue, type, name);

  /// Create a copy of TypeModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TypeModelImplCopyWith<_$TypeModelImpl> get copyWith =>
      __$$TypeModelImplCopyWithImpl<_$TypeModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TypeModelImplToJson(
      this,
    );
  }
}

abstract class _TypeModel implements TypeModel {
  const factory _TypeModel(
      {required final bool isRequired,
      required final bool isNullable,
      final String? defaultValue,
      required final String type,
      required final String name}) = _$TypeModelImpl;

  factory _TypeModel.fromJson(Map<String, dynamic> json) =
      _$TypeModelImpl.fromJson;

  @override
  bool get isRequired;
  @override
  bool get isNullable;
  @override
  String? get defaultValue;
  @override
  String get type;
  @override
  String get name;

  /// Create a copy of TypeModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TypeModelImplCopyWith<_$TypeModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

TypedefTemplateModel _$TypedefTemplateModelFromJson(Map<String, dynamic> json) {
  return _TypedefTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$TypedefTemplateModel {
  String get type => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  bool get hasFilter => throw _privateConstructorUsedError;

  /// Serializes this TypedefTemplateModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of TypedefTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $TypedefTemplateModelCopyWith<TypedefTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TypedefTemplateModelCopyWith<$Res> {
  factory $TypedefTemplateModelCopyWith(TypedefTemplateModel value,
          $Res Function(TypedefTemplateModel) then) =
      _$TypedefTemplateModelCopyWithImpl<$Res, TypedefTemplateModel>;
  @useResult
  $Res call({String type, String name, bool hasFilter});
}

/// @nodoc
class _$TypedefTemplateModelCopyWithImpl<$Res,
        $Val extends TypedefTemplateModel>
    implements $TypedefTemplateModelCopyWith<$Res> {
  _$TypedefTemplateModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of TypedefTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? name = null,
    Object? hasFilter = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: null == hasFilter
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TypedefTemplateModelImplCopyWith<$Res>
    implements $TypedefTemplateModelCopyWith<$Res> {
  factory _$$TypedefTemplateModelImplCopyWith(_$TypedefTemplateModelImpl value,
          $Res Function(_$TypedefTemplateModelImpl) then) =
      __$$TypedefTemplateModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String type, String name, bool hasFilter});
}

/// @nodoc
class __$$TypedefTemplateModelImplCopyWithImpl<$Res>
    extends _$TypedefTemplateModelCopyWithImpl<$Res, _$TypedefTemplateModelImpl>
    implements _$$TypedefTemplateModelImplCopyWith<$Res> {
  __$$TypedefTemplateModelImplCopyWithImpl(_$TypedefTemplateModelImpl _value,
      $Res Function(_$TypedefTemplateModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of TypedefTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? name = null,
    Object? hasFilter = null,
  }) {
    return _then(_$TypedefTemplateModelImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: null == hasFilter
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TypedefTemplateModelImpl implements _TypedefTemplateModel {
  const _$TypedefTemplateModelImpl(
      {required this.type, required this.name, this.hasFilter = false});

  factory _$TypedefTemplateModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$TypedefTemplateModelImplFromJson(json);

  @override
  final String type;
  @override
  final String name;
  @override
  @JsonKey()
  final bool hasFilter;

  @override
  String toString() {
    return 'TypedefTemplateModel(type: $type, name: $name, hasFilter: $hasFilter)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TypedefTemplateModelImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.hasFilter, hasFilter) ||
                other.hasFilter == hasFilter));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, name, hasFilter);

  /// Create a copy of TypedefTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TypedefTemplateModelImplCopyWith<_$TypedefTemplateModelImpl>
      get copyWith =>
          __$$TypedefTemplateModelImplCopyWithImpl<_$TypedefTemplateModelImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TypedefTemplateModelImplToJson(
      this,
    );
  }
}

abstract class _TypedefTemplateModel implements TypedefTemplateModel {
  const factory _TypedefTemplateModel(
      {required final String type,
      required final String name,
      final bool hasFilter}) = _$TypedefTemplateModelImpl;

  factory _TypedefTemplateModel.fromJson(Map<String, dynamic> json) =
      _$TypedefTemplateModelImpl.fromJson;

  @override
  String get type;
  @override
  String get name;
  @override
  bool get hasFilter;

  /// Create a copy of TypedefTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TypedefTemplateModelImplCopyWith<_$TypedefTemplateModelImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ListRepositoryTemplateModel _$ListRepositoryTemplateModelFromJson(
    Map<String, dynamic> json) {
  return _ListRepositoryTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$ListRepositoryTemplateModel {
  String get api => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  dynamic get hasRequiredParam => throw _privateConstructorUsedError;
  bool get isInline => throw _privateConstructorUsedError;
  List<MethodModel> get crudMethods => throw _privateConstructorUsedError;
  String get methodName => throw _privateConstructorUsedError;
  String get returnType => throw _privateConstructorUsedError;
  bool get hasFilter => throw _privateConstructorUsedError;
  List<ParamModel> get additionalParams => throw _privateConstructorUsedError;
  List<ParamModel> get filterParams => throw _privateConstructorUsedError;

  /// Serializes this ListRepositoryTemplateModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ListRepositoryTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ListRepositoryTemplateModelCopyWith<ListRepositoryTemplateModel>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListRepositoryTemplateModelCopyWith<$Res> {
  factory $ListRepositoryTemplateModelCopyWith(
          ListRepositoryTemplateModel value,
          $Res Function(ListRepositoryTemplateModel) then) =
      _$ListRepositoryTemplateModelCopyWithImpl<$Res,
          ListRepositoryTemplateModel>;
  @useResult
  $Res call(
      {String api,
      String name,
      dynamic hasRequiredParam,
      bool isInline,
      List<MethodModel> crudMethods,
      String methodName,
      String returnType,
      bool hasFilter,
      List<ParamModel> additionalParams,
      List<ParamModel> filterParams});
}

/// @nodoc
class _$ListRepositoryTemplateModelCopyWithImpl<$Res,
        $Val extends ListRepositoryTemplateModel>
    implements $ListRepositoryTemplateModelCopyWith<$Res> {
  _$ListRepositoryTemplateModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ListRepositoryTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? api = null,
    Object? name = null,
    Object? hasRequiredParam = freezed,
    Object? isInline = null,
    Object? crudMethods = null,
    Object? methodName = null,
    Object? returnType = null,
    Object? hasFilter = null,
    Object? additionalParams = null,
    Object? filterParams = null,
  }) {
    return _then(_value.copyWith(
      api: null == api
          ? _value.api
          : api // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      hasRequiredParam: freezed == hasRequiredParam
          ? _value.hasRequiredParam
          : hasRequiredParam // ignore: cast_nullable_to_non_nullable
              as dynamic,
      isInline: null == isInline
          ? _value.isInline
          : isInline // ignore: cast_nullable_to_non_nullable
              as bool,
      crudMethods: null == crudMethods
          ? _value.crudMethods
          : crudMethods // ignore: cast_nullable_to_non_nullable
              as List<MethodModel>,
      methodName: null == methodName
          ? _value.methodName
          : methodName // ignore: cast_nullable_to_non_nullable
              as String,
      returnType: null == returnType
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: null == hasFilter
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
      additionalParams: null == additionalParams
          ? _value.additionalParams
          : additionalParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
      filterParams: null == filterParams
          ? _value.filterParams
          : filterParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListRepositoryTemplateModelImplCopyWith<$Res>
    implements $ListRepositoryTemplateModelCopyWith<$Res> {
  factory _$$ListRepositoryTemplateModelImplCopyWith(
          _$ListRepositoryTemplateModelImpl value,
          $Res Function(_$ListRepositoryTemplateModelImpl) then) =
      __$$ListRepositoryTemplateModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String api,
      String name,
      dynamic hasRequiredParam,
      bool isInline,
      List<MethodModel> crudMethods,
      String methodName,
      String returnType,
      bool hasFilter,
      List<ParamModel> additionalParams,
      List<ParamModel> filterParams});
}

/// @nodoc
class __$$ListRepositoryTemplateModelImplCopyWithImpl<$Res>
    extends _$ListRepositoryTemplateModelCopyWithImpl<$Res,
        _$ListRepositoryTemplateModelImpl>
    implements _$$ListRepositoryTemplateModelImplCopyWith<$Res> {
  __$$ListRepositoryTemplateModelImplCopyWithImpl(
      _$ListRepositoryTemplateModelImpl _value,
      $Res Function(_$ListRepositoryTemplateModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of ListRepositoryTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? api = null,
    Object? name = null,
    Object? hasRequiredParam = freezed,
    Object? isInline = null,
    Object? crudMethods = null,
    Object? methodName = null,
    Object? returnType = null,
    Object? hasFilter = null,
    Object? additionalParams = null,
    Object? filterParams = null,
  }) {
    return _then(_$ListRepositoryTemplateModelImpl(
      api: null == api
          ? _value.api
          : api // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      hasRequiredParam: freezed == hasRequiredParam
          ? _value.hasRequiredParam!
          : hasRequiredParam,
      isInline: null == isInline
          ? _value.isInline
          : isInline // ignore: cast_nullable_to_non_nullable
              as bool,
      crudMethods: null == crudMethods
          ? _value._crudMethods
          : crudMethods // ignore: cast_nullable_to_non_nullable
              as List<MethodModel>,
      methodName: null == methodName
          ? _value.methodName
          : methodName // ignore: cast_nullable_to_non_nullable
              as String,
      returnType: null == returnType
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: null == hasFilter
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
      additionalParams: null == additionalParams
          ? _value._additionalParams
          : additionalParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
      filterParams: null == filterParams
          ? _value._filterParams
          : filterParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$ListRepositoryTemplateModelImpl
    implements _ListRepositoryTemplateModel {
  const _$ListRepositoryTemplateModelImpl(
      {required this.api,
      required this.name,
      this.hasRequiredParam = false,
      this.isInline = false,
      required final List<MethodModel> crudMethods,
      required this.methodName,
      required this.returnType,
      this.hasFilter = false,
      final List<ParamModel> additionalParams = const [],
      final List<ParamModel> filterParams = const []})
      : _crudMethods = crudMethods,
        _additionalParams = additionalParams,
        _filterParams = filterParams;

  factory _$ListRepositoryTemplateModelImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ListRepositoryTemplateModelImplFromJson(json);

  @override
  final String api;
  @override
  final String name;
  @override
  @JsonKey()
  final dynamic hasRequiredParam;
  @override
  @JsonKey()
  final bool isInline;
  final List<MethodModel> _crudMethods;
  @override
  List<MethodModel> get crudMethods {
    if (_crudMethods is EqualUnmodifiableListView) return _crudMethods;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_crudMethods);
  }

  @override
  final String methodName;
  @override
  final String returnType;
  @override
  @JsonKey()
  final bool hasFilter;
  final List<ParamModel> _additionalParams;
  @override
  @JsonKey()
  List<ParamModel> get additionalParams {
    if (_additionalParams is EqualUnmodifiableListView)
      return _additionalParams;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_additionalParams);
  }

  final List<ParamModel> _filterParams;
  @override
  @JsonKey()
  List<ParamModel> get filterParams {
    if (_filterParams is EqualUnmodifiableListView) return _filterParams;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_filterParams);
  }

  @override
  String toString() {
    return 'ListRepositoryTemplateModel(api: $api, name: $name, hasRequiredParam: $hasRequiredParam, isInline: $isInline, crudMethods: $crudMethods, methodName: $methodName, returnType: $returnType, hasFilter: $hasFilter, additionalParams: $additionalParams, filterParams: $filterParams)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListRepositoryTemplateModelImpl &&
            (identical(other.api, api) || other.api == api) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality()
                .equals(other.hasRequiredParam, hasRequiredParam) &&
            (identical(other.isInline, isInline) ||
                other.isInline == isInline) &&
            const DeepCollectionEquality()
                .equals(other._crudMethods, _crudMethods) &&
            (identical(other.methodName, methodName) ||
                other.methodName == methodName) &&
            (identical(other.returnType, returnType) ||
                other.returnType == returnType) &&
            (identical(other.hasFilter, hasFilter) ||
                other.hasFilter == hasFilter) &&
            const DeepCollectionEquality()
                .equals(other._additionalParams, _additionalParams) &&
            const DeepCollectionEquality()
                .equals(other._filterParams, _filterParams));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      api,
      name,
      const DeepCollectionEquality().hash(hasRequiredParam),
      isInline,
      const DeepCollectionEquality().hash(_crudMethods),
      methodName,
      returnType,
      hasFilter,
      const DeepCollectionEquality().hash(_additionalParams),
      const DeepCollectionEquality().hash(_filterParams));

  /// Create a copy of ListRepositoryTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ListRepositoryTemplateModelImplCopyWith<_$ListRepositoryTemplateModelImpl>
      get copyWith => __$$ListRepositoryTemplateModelImplCopyWithImpl<
          _$ListRepositoryTemplateModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListRepositoryTemplateModelImplToJson(
      this,
    );
  }
}

abstract class _ListRepositoryTemplateModel
    implements ListRepositoryTemplateModel {
  const factory _ListRepositoryTemplateModel(
      {required final String api,
      required final String name,
      final dynamic hasRequiredParam,
      final bool isInline,
      required final List<MethodModel> crudMethods,
      required final String methodName,
      required final String returnType,
      final bool hasFilter,
      final List<ParamModel> additionalParams,
      final List<ParamModel> filterParams}) = _$ListRepositoryTemplateModelImpl;

  factory _ListRepositoryTemplateModel.fromJson(Map<String, dynamic> json) =
      _$ListRepositoryTemplateModelImpl.fromJson;

  @override
  String get api;
  @override
  String get name;
  @override
  dynamic get hasRequiredParam;
  @override
  bool get isInline;
  @override
  List<MethodModel> get crudMethods;
  @override
  String get methodName;
  @override
  String get returnType;
  @override
  bool get hasFilter;
  @override
  List<ParamModel> get additionalParams;
  @override
  List<ParamModel> get filterParams;

  /// Create a copy of ListRepositoryTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ListRepositoryTemplateModelImplCopyWith<_$ListRepositoryTemplateModelImpl>
      get copyWith => throw _privateConstructorUsedError;
}

DataCubitTemplateModel _$DataCubitTemplateModelFromJson(
    Map<String, dynamic> json) {
  return _DataCubitTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$DataCubitTemplateModel {
  String get api => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  dynamic get hasRequiredParam => throw _privateConstructorUsedError;
  bool get isInline => throw _privateConstructorUsedError;
  List<MethodModel> get crudMethods => throw _privateConstructorUsedError;
  String get methodName => throw _privateConstructorUsedError;
  String get returnType => throw _privateConstructorUsedError;
  List<ParamModel> get additionalParams => throw _privateConstructorUsedError;

  /// Serializes this DataCubitTemplateModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of DataCubitTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DataCubitTemplateModelCopyWith<DataCubitTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DataCubitTemplateModelCopyWith<$Res> {
  factory $DataCubitTemplateModelCopyWith(DataCubitTemplateModel value,
          $Res Function(DataCubitTemplateModel) then) =
      _$DataCubitTemplateModelCopyWithImpl<$Res, DataCubitTemplateModel>;
  @useResult
  $Res call(
      {String api,
      String name,
      dynamic hasRequiredParam,
      bool isInline,
      List<MethodModel> crudMethods,
      String methodName,
      String returnType,
      List<ParamModel> additionalParams});
}

/// @nodoc
class _$DataCubitTemplateModelCopyWithImpl<$Res,
        $Val extends DataCubitTemplateModel>
    implements $DataCubitTemplateModelCopyWith<$Res> {
  _$DataCubitTemplateModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DataCubitTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? api = null,
    Object? name = null,
    Object? hasRequiredParam = freezed,
    Object? isInline = null,
    Object? crudMethods = null,
    Object? methodName = null,
    Object? returnType = null,
    Object? additionalParams = null,
  }) {
    return _then(_value.copyWith(
      api: null == api
          ? _value.api
          : api // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      hasRequiredParam: freezed == hasRequiredParam
          ? _value.hasRequiredParam
          : hasRequiredParam // ignore: cast_nullable_to_non_nullable
              as dynamic,
      isInline: null == isInline
          ? _value.isInline
          : isInline // ignore: cast_nullable_to_non_nullable
              as bool,
      crudMethods: null == crudMethods
          ? _value.crudMethods
          : crudMethods // ignore: cast_nullable_to_non_nullable
              as List<MethodModel>,
      methodName: null == methodName
          ? _value.methodName
          : methodName // ignore: cast_nullable_to_non_nullable
              as String,
      returnType: null == returnType
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      additionalParams: null == additionalParams
          ? _value.additionalParams
          : additionalParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DataCubitTemplateModelImplCopyWith<$Res>
    implements $DataCubitTemplateModelCopyWith<$Res> {
  factory _$$DataCubitTemplateModelImplCopyWith(
          _$DataCubitTemplateModelImpl value,
          $Res Function(_$DataCubitTemplateModelImpl) then) =
      __$$DataCubitTemplateModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String api,
      String name,
      dynamic hasRequiredParam,
      bool isInline,
      List<MethodModel> crudMethods,
      String methodName,
      String returnType,
      List<ParamModel> additionalParams});
}

/// @nodoc
class __$$DataCubitTemplateModelImplCopyWithImpl<$Res>
    extends _$DataCubitTemplateModelCopyWithImpl<$Res,
        _$DataCubitTemplateModelImpl>
    implements _$$DataCubitTemplateModelImplCopyWith<$Res> {
  __$$DataCubitTemplateModelImplCopyWithImpl(
      _$DataCubitTemplateModelImpl _value,
      $Res Function(_$DataCubitTemplateModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of DataCubitTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? api = null,
    Object? name = null,
    Object? hasRequiredParam = freezed,
    Object? isInline = null,
    Object? crudMethods = null,
    Object? methodName = null,
    Object? returnType = null,
    Object? additionalParams = null,
  }) {
    return _then(_$DataCubitTemplateModelImpl(
      api: null == api
          ? _value.api
          : api // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      hasRequiredParam: freezed == hasRequiredParam
          ? _value.hasRequiredParam!
          : hasRequiredParam,
      isInline: null == isInline
          ? _value.isInline
          : isInline // ignore: cast_nullable_to_non_nullable
              as bool,
      crudMethods: null == crudMethods
          ? _value._crudMethods
          : crudMethods // ignore: cast_nullable_to_non_nullable
              as List<MethodModel>,
      methodName: null == methodName
          ? _value.methodName
          : methodName // ignore: cast_nullable_to_non_nullable
              as String,
      returnType: null == returnType
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      additionalParams: null == additionalParams
          ? _value._additionalParams
          : additionalParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$DataCubitTemplateModelImpl implements _DataCubitTemplateModel {
  const _$DataCubitTemplateModelImpl(
      {required this.api,
      required this.name,
      this.hasRequiredParam = false,
      this.isInline = false,
      required final List<MethodModel> crudMethods,
      required this.methodName,
      required this.returnType,
      final List<ParamModel> additionalParams = const []})
      : _crudMethods = crudMethods,
        _additionalParams = additionalParams;

  factory _$DataCubitTemplateModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$DataCubitTemplateModelImplFromJson(json);

  @override
  final String api;
  @override
  final String name;
  @override
  @JsonKey()
  final dynamic hasRequiredParam;
  @override
  @JsonKey()
  final bool isInline;
  final List<MethodModel> _crudMethods;
  @override
  List<MethodModel> get crudMethods {
    if (_crudMethods is EqualUnmodifiableListView) return _crudMethods;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_crudMethods);
  }

  @override
  final String methodName;
  @override
  final String returnType;
  final List<ParamModel> _additionalParams;
  @override
  @JsonKey()
  List<ParamModel> get additionalParams {
    if (_additionalParams is EqualUnmodifiableListView)
      return _additionalParams;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_additionalParams);
  }

  @override
  String toString() {
    return 'DataCubitTemplateModel(api: $api, name: $name, hasRequiredParam: $hasRequiredParam, isInline: $isInline, crudMethods: $crudMethods, methodName: $methodName, returnType: $returnType, additionalParams: $additionalParams)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DataCubitTemplateModelImpl &&
            (identical(other.api, api) || other.api == api) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality()
                .equals(other.hasRequiredParam, hasRequiredParam) &&
            (identical(other.isInline, isInline) ||
                other.isInline == isInline) &&
            const DeepCollectionEquality()
                .equals(other._crudMethods, _crudMethods) &&
            (identical(other.methodName, methodName) ||
                other.methodName == methodName) &&
            (identical(other.returnType, returnType) ||
                other.returnType == returnType) &&
            const DeepCollectionEquality()
                .equals(other._additionalParams, _additionalParams));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      api,
      name,
      const DeepCollectionEquality().hash(hasRequiredParam),
      isInline,
      const DeepCollectionEquality().hash(_crudMethods),
      methodName,
      returnType,
      const DeepCollectionEquality().hash(_additionalParams));

  /// Create a copy of DataCubitTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DataCubitTemplateModelImplCopyWith<_$DataCubitTemplateModelImpl>
      get copyWith => __$$DataCubitTemplateModelImplCopyWithImpl<
          _$DataCubitTemplateModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DataCubitTemplateModelImplToJson(
      this,
    );
  }
}

abstract class _DataCubitTemplateModel implements DataCubitTemplateModel {
  const factory _DataCubitTemplateModel(
      {required final String api,
      required final String name,
      final dynamic hasRequiredParam,
      final bool isInline,
      required final List<MethodModel> crudMethods,
      required final String methodName,
      required final String returnType,
      final List<ParamModel> additionalParams}) = _$DataCubitTemplateModelImpl;

  factory _DataCubitTemplateModel.fromJson(Map<String, dynamic> json) =
      _$DataCubitTemplateModelImpl.fromJson;

  @override
  String get api;
  @override
  String get name;
  @override
  dynamic get hasRequiredParam;
  @override
  bool get isInline;
  @override
  List<MethodModel> get crudMethods;
  @override
  String get methodName;
  @override
  String get returnType;
  @override
  List<ParamModel> get additionalParams;

  /// Create a copy of DataCubitTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DataCubitTemplateModelImplCopyWith<_$DataCubitTemplateModelImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ParamModel _$ParamModelFromJson(Map<String, dynamic> json) {
  return _ParamModel.fromJson(json);
}

/// @nodoc
mixin _$ParamModel {
  String get param => throw _privateConstructorUsedError;

  /// Serializes this ParamModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ParamModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ParamModelCopyWith<ParamModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ParamModelCopyWith<$Res> {
  factory $ParamModelCopyWith(
          ParamModel value, $Res Function(ParamModel) then) =
      _$ParamModelCopyWithImpl<$Res, ParamModel>;
  @useResult
  $Res call({String param});
}

/// @nodoc
class _$ParamModelCopyWithImpl<$Res, $Val extends ParamModel>
    implements $ParamModelCopyWith<$Res> {
  _$ParamModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ParamModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? param = null,
  }) {
    return _then(_value.copyWith(
      param: null == param
          ? _value.param
          : param // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ParamModelImplCopyWith<$Res>
    implements $ParamModelCopyWith<$Res> {
  factory _$$ParamModelImplCopyWith(
          _$ParamModelImpl value, $Res Function(_$ParamModelImpl) then) =
      __$$ParamModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String param});
}

/// @nodoc
class __$$ParamModelImplCopyWithImpl<$Res>
    extends _$ParamModelCopyWithImpl<$Res, _$ParamModelImpl>
    implements _$$ParamModelImplCopyWith<$Res> {
  __$$ParamModelImplCopyWithImpl(
      _$ParamModelImpl _value, $Res Function(_$ParamModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of ParamModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? param = null,
  }) {
    return _then(_$ParamModelImpl(
      null == param
          ? _value.param
          : param // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ParamModelImpl implements _ParamModel {
  const _$ParamModelImpl(this.param);

  factory _$ParamModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$ParamModelImplFromJson(json);

  @override
  final String param;

  @override
  String toString() {
    return 'ParamModel(param: $param)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ParamModelImpl &&
            (identical(other.param, param) || other.param == param));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, param);

  /// Create a copy of ParamModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ParamModelImplCopyWith<_$ParamModelImpl> get copyWith =>
      __$$ParamModelImplCopyWithImpl<_$ParamModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ParamModelImplToJson(
      this,
    );
  }
}

abstract class _ParamModel implements ParamModel {
  const factory _ParamModel(final String param) = _$ParamModelImpl;

  factory _ParamModel.fromJson(Map<String, dynamic> json) =
      _$ParamModelImpl.fromJson;

  @override
  String get param;

  /// Create a copy of ParamModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ParamModelImplCopyWith<_$ParamModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AnnotationModel _$AnnotationModelFromJson(Map<String, dynamic> json) {
  return _AnnotationModel.fromJson(json);
}

/// @nodoc
mixin _$AnnotationModel {
  String get annotation => throw _privateConstructorUsedError;

  /// Serializes this AnnotationModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AnnotationModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AnnotationModelCopyWith<AnnotationModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnnotationModelCopyWith<$Res> {
  factory $AnnotationModelCopyWith(
          AnnotationModel value, $Res Function(AnnotationModel) then) =
      _$AnnotationModelCopyWithImpl<$Res, AnnotationModel>;
  @useResult
  $Res call({String annotation});
}

/// @nodoc
class _$AnnotationModelCopyWithImpl<$Res, $Val extends AnnotationModel>
    implements $AnnotationModelCopyWith<$Res> {
  _$AnnotationModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AnnotationModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? annotation = null,
  }) {
    return _then(_value.copyWith(
      annotation: null == annotation
          ? _value.annotation
          : annotation // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AnnotationModelImplCopyWith<$Res>
    implements $AnnotationModelCopyWith<$Res> {
  factory _$$AnnotationModelImplCopyWith(_$AnnotationModelImpl value,
          $Res Function(_$AnnotationModelImpl) then) =
      __$$AnnotationModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String annotation});
}

/// @nodoc
class __$$AnnotationModelImplCopyWithImpl<$Res>
    extends _$AnnotationModelCopyWithImpl<$Res, _$AnnotationModelImpl>
    implements _$$AnnotationModelImplCopyWith<$Res> {
  __$$AnnotationModelImplCopyWithImpl(
      _$AnnotationModelImpl _value, $Res Function(_$AnnotationModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of AnnotationModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? annotation = null,
  }) {
    return _then(_$AnnotationModelImpl(
      null == annotation
          ? _value.annotation
          : annotation // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AnnotationModelImpl implements _AnnotationModel {
  const _$AnnotationModelImpl(this.annotation);

  factory _$AnnotationModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$AnnotationModelImplFromJson(json);

  @override
  final String annotation;

  @override
  String toString() {
    return 'AnnotationModel(annotation: $annotation)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnnotationModelImpl &&
            (identical(other.annotation, annotation) ||
                other.annotation == annotation));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, annotation);

  /// Create a copy of AnnotationModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AnnotationModelImplCopyWith<_$AnnotationModelImpl> get copyWith =>
      __$$AnnotationModelImplCopyWithImpl<_$AnnotationModelImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AnnotationModelImplToJson(
      this,
    );
  }
}

abstract class _AnnotationModel implements AnnotationModel {
  const factory _AnnotationModel(final String annotation) =
      _$AnnotationModelImpl;

  factory _AnnotationModel.fromJson(Map<String, dynamic> json) =
      _$AnnotationModelImpl.fromJson;

  @override
  String get annotation;

  /// Create a copy of AnnotationModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AnnotationModelImplCopyWith<_$AnnotationModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ArgModel _$ArgModelFromJson(Map<String, dynamic> json) {
  return _ArgModelModel.fromJson(json);
}

/// @nodoc
mixin _$ArgModel {
  String get argType => throw _privateConstructorUsedError;
  String get argName => throw _privateConstructorUsedError;
  bool get isNullableArg => throw _privateConstructorUsedError;
  bool get isRequiredArg => throw _privateConstructorUsedError;

  /// Serializes this ArgModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ArgModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ArgModelCopyWith<ArgModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ArgModelCopyWith<$Res> {
  factory $ArgModelCopyWith(ArgModel value, $Res Function(ArgModel) then) =
      _$ArgModelCopyWithImpl<$Res, ArgModel>;
  @useResult
  $Res call(
      {String argType, String argName, bool isNullableArg, bool isRequiredArg});
}

/// @nodoc
class _$ArgModelCopyWithImpl<$Res, $Val extends ArgModel>
    implements $ArgModelCopyWith<$Res> {
  _$ArgModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ArgModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? argType = null,
    Object? argName = null,
    Object? isNullableArg = null,
    Object? isRequiredArg = null,
  }) {
    return _then(_value.copyWith(
      argType: null == argType
          ? _value.argType
          : argType // ignore: cast_nullable_to_non_nullable
              as String,
      argName: null == argName
          ? _value.argName
          : argName // ignore: cast_nullable_to_non_nullable
              as String,
      isNullableArg: null == isNullableArg
          ? _value.isNullableArg
          : isNullableArg // ignore: cast_nullable_to_non_nullable
              as bool,
      isRequiredArg: null == isRequiredArg
          ? _value.isRequiredArg
          : isRequiredArg // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ArgModelModelImplCopyWith<$Res>
    implements $ArgModelCopyWith<$Res> {
  factory _$$ArgModelModelImplCopyWith(
          _$ArgModelModelImpl value, $Res Function(_$ArgModelModelImpl) then) =
      __$$ArgModelModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String argType, String argName, bool isNullableArg, bool isRequiredArg});
}

/// @nodoc
class __$$ArgModelModelImplCopyWithImpl<$Res>
    extends _$ArgModelCopyWithImpl<$Res, _$ArgModelModelImpl>
    implements _$$ArgModelModelImplCopyWith<$Res> {
  __$$ArgModelModelImplCopyWithImpl(
      _$ArgModelModelImpl _value, $Res Function(_$ArgModelModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of ArgModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? argType = null,
    Object? argName = null,
    Object? isNullableArg = null,
    Object? isRequiredArg = null,
  }) {
    return _then(_$ArgModelModelImpl(
      null == argType
          ? _value.argType
          : argType // ignore: cast_nullable_to_non_nullable
              as String,
      null == argName
          ? _value.argName
          : argName // ignore: cast_nullable_to_non_nullable
              as String,
      null == isNullableArg
          ? _value.isNullableArg
          : isNullableArg // ignore: cast_nullable_to_non_nullable
              as bool,
      null == isRequiredArg
          ? _value.isRequiredArg
          : isRequiredArg // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ArgModelModelImpl implements _ArgModelModel {
  const _$ArgModelModelImpl(
      this.argType, this.argName, this.isNullableArg, this.isRequiredArg);

  factory _$ArgModelModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$ArgModelModelImplFromJson(json);

  @override
  final String argType;
  @override
  final String argName;
  @override
  final bool isNullableArg;
  @override
  final bool isRequiredArg;

  @override
  String toString() {
    return 'ArgModel(argType: $argType, argName: $argName, isNullableArg: $isNullableArg, isRequiredArg: $isRequiredArg)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ArgModelModelImpl &&
            (identical(other.argType, argType) || other.argType == argType) &&
            (identical(other.argName, argName) || other.argName == argName) &&
            (identical(other.isNullableArg, isNullableArg) ||
                other.isNullableArg == isNullableArg) &&
            (identical(other.isRequiredArg, isRequiredArg) ||
                other.isRequiredArg == isRequiredArg));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, argType, argName, isNullableArg, isRequiredArg);

  /// Create a copy of ArgModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ArgModelModelImplCopyWith<_$ArgModelModelImpl> get copyWith =>
      __$$ArgModelModelImplCopyWithImpl<_$ArgModelModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ArgModelModelImplToJson(
      this,
    );
  }
}

abstract class _ArgModelModel implements ArgModel {
  const factory _ArgModelModel(final String argType, final String argName,
      final bool isNullableArg, final bool isRequiredArg) = _$ArgModelModelImpl;

  factory _ArgModelModel.fromJson(Map<String, dynamic> json) =
      _$ArgModelModelImpl.fromJson;

  @override
  String get argType;
  @override
  String get argName;
  @override
  bool get isNullableArg;
  @override
  bool get isRequiredArg;

  /// Create a copy of ArgModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ArgModelModelImplCopyWith<_$ArgModelModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

MethodModel _$MethodModelFromJson(Map<String, dynamic> json) {
  return _MethodModel.fromJson(json);
}

/// @nodoc
mixin _$MethodModel {
  String get returnType => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get operation => throw _privateConstructorUsedError;
  List<ArgModel> get arguments => throw _privateConstructorUsedError;
  List<ParamModel> get parameters => throw _privateConstructorUsedError;
  bool get isEmptyArgs => throw _privateConstructorUsedError;
  bool get isList => throw _privateConstructorUsedError;
  bool get shouldUseAsList => throw _privateConstructorUsedError;

  /// Serializes this MethodModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of MethodModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MethodModelCopyWith<MethodModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MethodModelCopyWith<$Res> {
  factory $MethodModelCopyWith(
          MethodModel value, $Res Function(MethodModel) then) =
      _$MethodModelCopyWithImpl<$Res, MethodModel>;
  @useResult
  $Res call(
      {String returnType,
      String name,
      String operation,
      List<ArgModel> arguments,
      List<ParamModel> parameters,
      bool isEmptyArgs,
      bool isList,
      bool shouldUseAsList});
}

/// @nodoc
class _$MethodModelCopyWithImpl<$Res, $Val extends MethodModel>
    implements $MethodModelCopyWith<$Res> {
  _$MethodModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MethodModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? returnType = null,
    Object? name = null,
    Object? operation = null,
    Object? arguments = null,
    Object? parameters = null,
    Object? isEmptyArgs = null,
    Object? isList = null,
    Object? shouldUseAsList = null,
  }) {
    return _then(_value.copyWith(
      returnType: null == returnType
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      operation: null == operation
          ? _value.operation
          : operation // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as List<ArgModel>,
      parameters: null == parameters
          ? _value.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
      isEmptyArgs: null == isEmptyArgs
          ? _value.isEmptyArgs
          : isEmptyArgs // ignore: cast_nullable_to_non_nullable
              as bool,
      isList: null == isList
          ? _value.isList
          : isList // ignore: cast_nullable_to_non_nullable
              as bool,
      shouldUseAsList: null == shouldUseAsList
          ? _value.shouldUseAsList
          : shouldUseAsList // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MethodModelImplCopyWith<$Res>
    implements $MethodModelCopyWith<$Res> {
  factory _$$MethodModelImplCopyWith(
          _$MethodModelImpl value, $Res Function(_$MethodModelImpl) then) =
      __$$MethodModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String returnType,
      String name,
      String operation,
      List<ArgModel> arguments,
      List<ParamModel> parameters,
      bool isEmptyArgs,
      bool isList,
      bool shouldUseAsList});
}

/// @nodoc
class __$$MethodModelImplCopyWithImpl<$Res>
    extends _$MethodModelCopyWithImpl<$Res, _$MethodModelImpl>
    implements _$$MethodModelImplCopyWith<$Res> {
  __$$MethodModelImplCopyWithImpl(
      _$MethodModelImpl _value, $Res Function(_$MethodModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of MethodModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? returnType = null,
    Object? name = null,
    Object? operation = null,
    Object? arguments = null,
    Object? parameters = null,
    Object? isEmptyArgs = null,
    Object? isList = null,
    Object? shouldUseAsList = null,
  }) {
    return _then(_$MethodModelImpl(
      returnType: null == returnType
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      operation: null == operation
          ? _value.operation
          : operation // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _value._arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as List<ArgModel>,
      parameters: null == parameters
          ? _value._parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
      isEmptyArgs: null == isEmptyArgs
          ? _value.isEmptyArgs
          : isEmptyArgs // ignore: cast_nullable_to_non_nullable
              as bool,
      isList: null == isList
          ? _value.isList
          : isList // ignore: cast_nullable_to_non_nullable
              as bool,
      shouldUseAsList: null == shouldUseAsList
          ? _value.shouldUseAsList
          : shouldUseAsList // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$MethodModelImpl implements _MethodModel {
  const _$MethodModelImpl(
      {required this.returnType,
      required this.name,
      required this.operation,
      required final List<ArgModel> arguments,
      required final List<ParamModel> parameters,
      this.isEmptyArgs = false,
      this.isList = false,
      this.shouldUseAsList = false})
      : _arguments = arguments,
        _parameters = parameters;

  factory _$MethodModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$MethodModelImplFromJson(json);

  @override
  final String returnType;
  @override
  final String name;
  @override
  final String operation;
  final List<ArgModel> _arguments;
  @override
  List<ArgModel> get arguments {
    if (_arguments is EqualUnmodifiableListView) return _arguments;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_arguments);
  }

  final List<ParamModel> _parameters;
  @override
  List<ParamModel> get parameters {
    if (_parameters is EqualUnmodifiableListView) return _parameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_parameters);
  }

  @override
  @JsonKey()
  final bool isEmptyArgs;
  @override
  @JsonKey()
  final bool isList;
  @override
  @JsonKey()
  final bool shouldUseAsList;

  @override
  String toString() {
    return 'MethodModel(returnType: $returnType, name: $name, operation: $operation, arguments: $arguments, parameters: $parameters, isEmptyArgs: $isEmptyArgs, isList: $isList, shouldUseAsList: $shouldUseAsList)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MethodModelImpl &&
            (identical(other.returnType, returnType) ||
                other.returnType == returnType) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.operation, operation) ||
                other.operation == operation) &&
            const DeepCollectionEquality()
                .equals(other._arguments, _arguments) &&
            const DeepCollectionEquality()
                .equals(other._parameters, _parameters) &&
            (identical(other.isEmptyArgs, isEmptyArgs) ||
                other.isEmptyArgs == isEmptyArgs) &&
            (identical(other.isList, isList) || other.isList == isList) &&
            (identical(other.shouldUseAsList, shouldUseAsList) ||
                other.shouldUseAsList == shouldUseAsList));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      returnType,
      name,
      operation,
      const DeepCollectionEquality().hash(_arguments),
      const DeepCollectionEquality().hash(_parameters),
      isEmptyArgs,
      isList,
      shouldUseAsList);

  /// Create a copy of MethodModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MethodModelImplCopyWith<_$MethodModelImpl> get copyWith =>
      __$$MethodModelImplCopyWithImpl<_$MethodModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MethodModelImplToJson(
      this,
    );
  }
}

abstract class _MethodModel implements MethodModel {
  const factory _MethodModel(
      {required final String returnType,
      required final String name,
      required final String operation,
      required final List<ArgModel> arguments,
      required final List<ParamModel> parameters,
      final bool isEmptyArgs,
      final bool isList,
      final bool shouldUseAsList}) = _$MethodModelImpl;

  factory _MethodModel.fromJson(Map<String, dynamic> json) =
      _$MethodModelImpl.fromJson;

  @override
  String get returnType;
  @override
  String get name;
  @override
  String get operation;
  @override
  List<ArgModel> get arguments;
  @override
  List<ParamModel> get parameters;
  @override
  bool get isEmptyArgs;
  @override
  bool get isList;
  @override
  bool get shouldUseAsList;

  /// Create a copy of MethodModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MethodModelImplCopyWith<_$MethodModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

LoaderMethodModel _$LoaderMethodModelFromJson(Map<String, dynamic> json) {
  return _LoaderMethodModel.fromJson(json);
}

/// @nodoc
mixin _$LoaderMethodModel {
  String get returnType => throw _privateConstructorUsedError;
  String get nullabilitySuffix => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  bool get hasFilter => throw _privateConstructorUsedError;
  bool get isListLoader => throw _privateConstructorUsedError;
  bool get isPaginated => throw _privateConstructorUsedError;
  bool get hasRequiredParam => throw _privateConstructorUsedError;
  List<TypeModel> get types => throw _privateConstructorUsedError;
  List<ParamModel> get filterParams => throw _privateConstructorUsedError;
  int get defaultOffset => throw _privateConstructorUsedError;
  int get defaultPageSize => throw _privateConstructorUsedError;
  List<BuiltListJsonConverterModel> get builtListConverters =>
      throw _privateConstructorUsedError;
  bool get isInline => throw _privateConstructorUsedError;
  bool get shouldUseAsList => throw _privateConstructorUsedError;

  /// Serializes this LoaderMethodModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of LoaderMethodModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $LoaderMethodModelCopyWith<LoaderMethodModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoaderMethodModelCopyWith<$Res> {
  factory $LoaderMethodModelCopyWith(
          LoaderMethodModel value, $Res Function(LoaderMethodModel) then) =
      _$LoaderMethodModelCopyWithImpl<$Res, LoaderMethodModel>;
  @useResult
  $Res call(
      {String returnType,
      String nullabilitySuffix,
      String name,
      bool hasFilter,
      bool isListLoader,
      bool isPaginated,
      bool hasRequiredParam,
      List<TypeModel> types,
      List<ParamModel> filterParams,
      int defaultOffset,
      int defaultPageSize,
      List<BuiltListJsonConverterModel> builtListConverters,
      bool isInline,
      bool shouldUseAsList});
}

/// @nodoc
class _$LoaderMethodModelCopyWithImpl<$Res, $Val extends LoaderMethodModel>
    implements $LoaderMethodModelCopyWith<$Res> {
  _$LoaderMethodModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of LoaderMethodModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? returnType = null,
    Object? nullabilitySuffix = null,
    Object? name = null,
    Object? hasFilter = null,
    Object? isListLoader = null,
    Object? isPaginated = null,
    Object? hasRequiredParam = null,
    Object? types = null,
    Object? filterParams = null,
    Object? defaultOffset = null,
    Object? defaultPageSize = null,
    Object? builtListConverters = null,
    Object? isInline = null,
    Object? shouldUseAsList = null,
  }) {
    return _then(_value.copyWith(
      returnType: null == returnType
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      nullabilitySuffix: null == nullabilitySuffix
          ? _value.nullabilitySuffix
          : nullabilitySuffix // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: null == hasFilter
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
      isListLoader: null == isListLoader
          ? _value.isListLoader
          : isListLoader // ignore: cast_nullable_to_non_nullable
              as bool,
      isPaginated: null == isPaginated
          ? _value.isPaginated
          : isPaginated // ignore: cast_nullable_to_non_nullable
              as bool,
      hasRequiredParam: null == hasRequiredParam
          ? _value.hasRequiredParam
          : hasRequiredParam // ignore: cast_nullable_to_non_nullable
              as bool,
      types: null == types
          ? _value.types
          : types // ignore: cast_nullable_to_non_nullable
              as List<TypeModel>,
      filterParams: null == filterParams
          ? _value.filterParams
          : filterParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
      defaultOffset: null == defaultOffset
          ? _value.defaultOffset
          : defaultOffset // ignore: cast_nullable_to_non_nullable
              as int,
      defaultPageSize: null == defaultPageSize
          ? _value.defaultPageSize
          : defaultPageSize // ignore: cast_nullable_to_non_nullable
              as int,
      builtListConverters: null == builtListConverters
          ? _value.builtListConverters
          : builtListConverters // ignore: cast_nullable_to_non_nullable
              as List<BuiltListJsonConverterModel>,
      isInline: null == isInline
          ? _value.isInline
          : isInline // ignore: cast_nullable_to_non_nullable
              as bool,
      shouldUseAsList: null == shouldUseAsList
          ? _value.shouldUseAsList
          : shouldUseAsList // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LoaderMethodModelImplCopyWith<$Res>
    implements $LoaderMethodModelCopyWith<$Res> {
  factory _$$LoaderMethodModelImplCopyWith(_$LoaderMethodModelImpl value,
          $Res Function(_$LoaderMethodModelImpl) then) =
      __$$LoaderMethodModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String returnType,
      String nullabilitySuffix,
      String name,
      bool hasFilter,
      bool isListLoader,
      bool isPaginated,
      bool hasRequiredParam,
      List<TypeModel> types,
      List<ParamModel> filterParams,
      int defaultOffset,
      int defaultPageSize,
      List<BuiltListJsonConverterModel> builtListConverters,
      bool isInline,
      bool shouldUseAsList});
}

/// @nodoc
class __$$LoaderMethodModelImplCopyWithImpl<$Res>
    extends _$LoaderMethodModelCopyWithImpl<$Res, _$LoaderMethodModelImpl>
    implements _$$LoaderMethodModelImplCopyWith<$Res> {
  __$$LoaderMethodModelImplCopyWithImpl(_$LoaderMethodModelImpl _value,
      $Res Function(_$LoaderMethodModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of LoaderMethodModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? returnType = null,
    Object? nullabilitySuffix = null,
    Object? name = null,
    Object? hasFilter = null,
    Object? isListLoader = null,
    Object? isPaginated = null,
    Object? hasRequiredParam = null,
    Object? types = null,
    Object? filterParams = null,
    Object? defaultOffset = null,
    Object? defaultPageSize = null,
    Object? builtListConverters = null,
    Object? isInline = null,
    Object? shouldUseAsList = null,
  }) {
    return _then(_$LoaderMethodModelImpl(
      returnType: null == returnType
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      nullabilitySuffix: null == nullabilitySuffix
          ? _value.nullabilitySuffix
          : nullabilitySuffix // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: null == hasFilter
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
      isListLoader: null == isListLoader
          ? _value.isListLoader
          : isListLoader // ignore: cast_nullable_to_non_nullable
              as bool,
      isPaginated: null == isPaginated
          ? _value.isPaginated
          : isPaginated // ignore: cast_nullable_to_non_nullable
              as bool,
      hasRequiredParam: null == hasRequiredParam
          ? _value.hasRequiredParam
          : hasRequiredParam // ignore: cast_nullable_to_non_nullable
              as bool,
      types: null == types
          ? _value._types
          : types // ignore: cast_nullable_to_non_nullable
              as List<TypeModel>,
      filterParams: null == filterParams
          ? _value._filterParams
          : filterParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
      defaultOffset: null == defaultOffset
          ? _value.defaultOffset
          : defaultOffset // ignore: cast_nullable_to_non_nullable
              as int,
      defaultPageSize: null == defaultPageSize
          ? _value.defaultPageSize
          : defaultPageSize // ignore: cast_nullable_to_non_nullable
              as int,
      builtListConverters: null == builtListConverters
          ? _value._builtListConverters
          : builtListConverters // ignore: cast_nullable_to_non_nullable
              as List<BuiltListJsonConverterModel>,
      isInline: null == isInline
          ? _value.isInline
          : isInline // ignore: cast_nullable_to_non_nullable
              as bool,
      shouldUseAsList: null == shouldUseAsList
          ? _value.shouldUseAsList
          : shouldUseAsList // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$LoaderMethodModelImpl implements _LoaderMethodModel {
  const _$LoaderMethodModelImpl(
      {required this.returnType,
      required this.nullabilitySuffix,
      required this.name,
      required this.hasFilter,
      required this.isListLoader,
      required this.isPaginated,
      required this.hasRequiredParam,
      required final List<TypeModel> types,
      required final List<ParamModel> filterParams,
      required this.defaultOffset,
      required this.defaultPageSize,
      final List<BuiltListJsonConverterModel> builtListConverters =
          const <BuiltListJsonConverterModel>[],
      this.isInline = false,
      this.shouldUseAsList = false})
      : _types = types,
        _filterParams = filterParams,
        _builtListConverters = builtListConverters;

  factory _$LoaderMethodModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$LoaderMethodModelImplFromJson(json);

  @override
  final String returnType;
  @override
  final String nullabilitySuffix;
  @override
  final String name;
  @override
  final bool hasFilter;
  @override
  final bool isListLoader;
  @override
  final bool isPaginated;
  @override
  final bool hasRequiredParam;
  final List<TypeModel> _types;
  @override
  List<TypeModel> get types {
    if (_types is EqualUnmodifiableListView) return _types;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_types);
  }

  final List<ParamModel> _filterParams;
  @override
  List<ParamModel> get filterParams {
    if (_filterParams is EqualUnmodifiableListView) return _filterParams;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_filterParams);
  }

  @override
  final int defaultOffset;
  @override
  final int defaultPageSize;
  final List<BuiltListJsonConverterModel> _builtListConverters;
  @override
  @JsonKey()
  List<BuiltListJsonConverterModel> get builtListConverters {
    if (_builtListConverters is EqualUnmodifiableListView)
      return _builtListConverters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_builtListConverters);
  }

  @override
  @JsonKey()
  final bool isInline;
  @override
  @JsonKey()
  final bool shouldUseAsList;

  @override
  String toString() {
    return 'LoaderMethodModel(returnType: $returnType, nullabilitySuffix: $nullabilitySuffix, name: $name, hasFilter: $hasFilter, isListLoader: $isListLoader, isPaginated: $isPaginated, hasRequiredParam: $hasRequiredParam, types: $types, filterParams: $filterParams, defaultOffset: $defaultOffset, defaultPageSize: $defaultPageSize, builtListConverters: $builtListConverters, isInline: $isInline, shouldUseAsList: $shouldUseAsList)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoaderMethodModelImpl &&
            (identical(other.returnType, returnType) ||
                other.returnType == returnType) &&
            (identical(other.nullabilitySuffix, nullabilitySuffix) ||
                other.nullabilitySuffix == nullabilitySuffix) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.hasFilter, hasFilter) ||
                other.hasFilter == hasFilter) &&
            (identical(other.isListLoader, isListLoader) ||
                other.isListLoader == isListLoader) &&
            (identical(other.isPaginated, isPaginated) ||
                other.isPaginated == isPaginated) &&
            (identical(other.hasRequiredParam, hasRequiredParam) ||
                other.hasRequiredParam == hasRequiredParam) &&
            const DeepCollectionEquality().equals(other._types, _types) &&
            const DeepCollectionEquality()
                .equals(other._filterParams, _filterParams) &&
            (identical(other.defaultOffset, defaultOffset) ||
                other.defaultOffset == defaultOffset) &&
            (identical(other.defaultPageSize, defaultPageSize) ||
                other.defaultPageSize == defaultPageSize) &&
            const DeepCollectionEquality()
                .equals(other._builtListConverters, _builtListConverters) &&
            (identical(other.isInline, isInline) ||
                other.isInline == isInline) &&
            (identical(other.shouldUseAsList, shouldUseAsList) ||
                other.shouldUseAsList == shouldUseAsList));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      returnType,
      nullabilitySuffix,
      name,
      hasFilter,
      isListLoader,
      isPaginated,
      hasRequiredParam,
      const DeepCollectionEquality().hash(_types),
      const DeepCollectionEquality().hash(_filterParams),
      defaultOffset,
      defaultPageSize,
      const DeepCollectionEquality().hash(_builtListConverters),
      isInline,
      shouldUseAsList);

  /// Create a copy of LoaderMethodModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LoaderMethodModelImplCopyWith<_$LoaderMethodModelImpl> get copyWith =>
      __$$LoaderMethodModelImplCopyWithImpl<_$LoaderMethodModelImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LoaderMethodModelImplToJson(
      this,
    );
  }
}

abstract class _LoaderMethodModel implements LoaderMethodModel {
  const factory _LoaderMethodModel(
      {required final String returnType,
      required final String nullabilitySuffix,
      required final String name,
      required final bool hasFilter,
      required final bool isListLoader,
      required final bool isPaginated,
      required final bool hasRequiredParam,
      required final List<TypeModel> types,
      required final List<ParamModel> filterParams,
      required final int defaultOffset,
      required final int defaultPageSize,
      final List<BuiltListJsonConverterModel> builtListConverters,
      final bool isInline,
      final bool shouldUseAsList}) = _$LoaderMethodModelImpl;

  factory _LoaderMethodModel.fromJson(Map<String, dynamic> json) =
      _$LoaderMethodModelImpl.fromJson;

  @override
  String get returnType;
  @override
  String get nullabilitySuffix;
  @override
  String get name;
  @override
  bool get hasFilter;
  @override
  bool get isListLoader;
  @override
  bool get isPaginated;
  @override
  bool get hasRequiredParam;
  @override
  List<TypeModel> get types;
  @override
  List<ParamModel> get filterParams;
  @override
  int get defaultOffset;
  @override
  int get defaultPageSize;
  @override
  List<BuiltListJsonConverterModel> get builtListConverters;
  @override
  bool get isInline;
  @override
  bool get shouldUseAsList;

  /// Create a copy of LoaderMethodModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LoaderMethodModelImplCopyWith<_$LoaderMethodModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

LoaderRepositoryTemplateModel _$LoaderRepositoryTemplateModelFromJson(
    Map<String, dynamic> json) {
  return _LoaderRepositoryTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$LoaderRepositoryTemplateModel {
  LoaderTemplateModel? get dataLoader => throw _privateConstructorUsedError;
  LoaderTemplateModel? get listLoader => throw _privateConstructorUsedError;
  bool get hasDataLoader => throw _privateConstructorUsedError;
  bool get hasListLoader => throw _privateConstructorUsedError;
  List<MethodModel> get crudMethods => throw _privateConstructorUsedError;
  String get repositoryName => throw _privateConstructorUsedError;
  String get api => throw _privateConstructorUsedError;
  String get dataLoaderMethodName => throw _privateConstructorUsedError;
  String get listLoaderMethodName => throw _privateConstructorUsedError;
  String get dataFilterSuffix => throw _privateConstructorUsedError;
  String get listFilterSuffix => throw _privateConstructorUsedError;

  /// Serializes this LoaderRepositoryTemplateModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of LoaderRepositoryTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $LoaderRepositoryTemplateModelCopyWith<LoaderRepositoryTemplateModel>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoaderRepositoryTemplateModelCopyWith<$Res> {
  factory $LoaderRepositoryTemplateModelCopyWith(
          LoaderRepositoryTemplateModel value,
          $Res Function(LoaderRepositoryTemplateModel) then) =
      _$LoaderRepositoryTemplateModelCopyWithImpl<$Res,
          LoaderRepositoryTemplateModel>;
  @useResult
  $Res call(
      {LoaderTemplateModel? dataLoader,
      LoaderTemplateModel? listLoader,
      bool hasDataLoader,
      bool hasListLoader,
      List<MethodModel> crudMethods,
      String repositoryName,
      String api,
      String dataLoaderMethodName,
      String listLoaderMethodName,
      String dataFilterSuffix,
      String listFilterSuffix});

  $LoaderTemplateModelCopyWith<$Res>? get dataLoader;
  $LoaderTemplateModelCopyWith<$Res>? get listLoader;
}

/// @nodoc
class _$LoaderRepositoryTemplateModelCopyWithImpl<$Res,
        $Val extends LoaderRepositoryTemplateModel>
    implements $LoaderRepositoryTemplateModelCopyWith<$Res> {
  _$LoaderRepositoryTemplateModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of LoaderRepositoryTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dataLoader = freezed,
    Object? listLoader = freezed,
    Object? hasDataLoader = null,
    Object? hasListLoader = null,
    Object? crudMethods = null,
    Object? repositoryName = null,
    Object? api = null,
    Object? dataLoaderMethodName = null,
    Object? listLoaderMethodName = null,
    Object? dataFilterSuffix = null,
    Object? listFilterSuffix = null,
  }) {
    return _then(_value.copyWith(
      dataLoader: freezed == dataLoader
          ? _value.dataLoader
          : dataLoader // ignore: cast_nullable_to_non_nullable
              as LoaderTemplateModel?,
      listLoader: freezed == listLoader
          ? _value.listLoader
          : listLoader // ignore: cast_nullable_to_non_nullable
              as LoaderTemplateModel?,
      hasDataLoader: null == hasDataLoader
          ? _value.hasDataLoader
          : hasDataLoader // ignore: cast_nullable_to_non_nullable
              as bool,
      hasListLoader: null == hasListLoader
          ? _value.hasListLoader
          : hasListLoader // ignore: cast_nullable_to_non_nullable
              as bool,
      crudMethods: null == crudMethods
          ? _value.crudMethods
          : crudMethods // ignore: cast_nullable_to_non_nullable
              as List<MethodModel>,
      repositoryName: null == repositoryName
          ? _value.repositoryName
          : repositoryName // ignore: cast_nullable_to_non_nullable
              as String,
      api: null == api
          ? _value.api
          : api // ignore: cast_nullable_to_non_nullable
              as String,
      dataLoaderMethodName: null == dataLoaderMethodName
          ? _value.dataLoaderMethodName
          : dataLoaderMethodName // ignore: cast_nullable_to_non_nullable
              as String,
      listLoaderMethodName: null == listLoaderMethodName
          ? _value.listLoaderMethodName
          : listLoaderMethodName // ignore: cast_nullable_to_non_nullable
              as String,
      dataFilterSuffix: null == dataFilterSuffix
          ? _value.dataFilterSuffix
          : dataFilterSuffix // ignore: cast_nullable_to_non_nullable
              as String,
      listFilterSuffix: null == listFilterSuffix
          ? _value.listFilterSuffix
          : listFilterSuffix // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }

  /// Create a copy of LoaderRepositoryTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LoaderTemplateModelCopyWith<$Res>? get dataLoader {
    if (_value.dataLoader == null) {
      return null;
    }

    return $LoaderTemplateModelCopyWith<$Res>(_value.dataLoader!, (value) {
      return _then(_value.copyWith(dataLoader: value) as $Val);
    });
  }

  /// Create a copy of LoaderRepositoryTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LoaderTemplateModelCopyWith<$Res>? get listLoader {
    if (_value.listLoader == null) {
      return null;
    }

    return $LoaderTemplateModelCopyWith<$Res>(_value.listLoader!, (value) {
      return _then(_value.copyWith(listLoader: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$LoaderRepositoryTemplateModelImplCopyWith<$Res>
    implements $LoaderRepositoryTemplateModelCopyWith<$Res> {
  factory _$$LoaderRepositoryTemplateModelImplCopyWith(
          _$LoaderRepositoryTemplateModelImpl value,
          $Res Function(_$LoaderRepositoryTemplateModelImpl) then) =
      __$$LoaderRepositoryTemplateModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {LoaderTemplateModel? dataLoader,
      LoaderTemplateModel? listLoader,
      bool hasDataLoader,
      bool hasListLoader,
      List<MethodModel> crudMethods,
      String repositoryName,
      String api,
      String dataLoaderMethodName,
      String listLoaderMethodName,
      String dataFilterSuffix,
      String listFilterSuffix});

  @override
  $LoaderTemplateModelCopyWith<$Res>? get dataLoader;
  @override
  $LoaderTemplateModelCopyWith<$Res>? get listLoader;
}

/// @nodoc
class __$$LoaderRepositoryTemplateModelImplCopyWithImpl<$Res>
    extends _$LoaderRepositoryTemplateModelCopyWithImpl<$Res,
        _$LoaderRepositoryTemplateModelImpl>
    implements _$$LoaderRepositoryTemplateModelImplCopyWith<$Res> {
  __$$LoaderRepositoryTemplateModelImplCopyWithImpl(
      _$LoaderRepositoryTemplateModelImpl _value,
      $Res Function(_$LoaderRepositoryTemplateModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of LoaderRepositoryTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dataLoader = freezed,
    Object? listLoader = freezed,
    Object? hasDataLoader = null,
    Object? hasListLoader = null,
    Object? crudMethods = null,
    Object? repositoryName = null,
    Object? api = null,
    Object? dataLoaderMethodName = null,
    Object? listLoaderMethodName = null,
    Object? dataFilterSuffix = null,
    Object? listFilterSuffix = null,
  }) {
    return _then(_$LoaderRepositoryTemplateModelImpl(
      dataLoader: freezed == dataLoader
          ? _value.dataLoader
          : dataLoader // ignore: cast_nullable_to_non_nullable
              as LoaderTemplateModel?,
      listLoader: freezed == listLoader
          ? _value.listLoader
          : listLoader // ignore: cast_nullable_to_non_nullable
              as LoaderTemplateModel?,
      hasDataLoader: null == hasDataLoader
          ? _value.hasDataLoader
          : hasDataLoader // ignore: cast_nullable_to_non_nullable
              as bool,
      hasListLoader: null == hasListLoader
          ? _value.hasListLoader
          : hasListLoader // ignore: cast_nullable_to_non_nullable
              as bool,
      crudMethods: null == crudMethods
          ? _value._crudMethods
          : crudMethods // ignore: cast_nullable_to_non_nullable
              as List<MethodModel>,
      repositoryName: null == repositoryName
          ? _value.repositoryName
          : repositoryName // ignore: cast_nullable_to_non_nullable
              as String,
      api: null == api
          ? _value.api
          : api // ignore: cast_nullable_to_non_nullable
              as String,
      dataLoaderMethodName: null == dataLoaderMethodName
          ? _value.dataLoaderMethodName
          : dataLoaderMethodName // ignore: cast_nullable_to_non_nullable
              as String,
      listLoaderMethodName: null == listLoaderMethodName
          ? _value.listLoaderMethodName
          : listLoaderMethodName // ignore: cast_nullable_to_non_nullable
              as String,
      dataFilterSuffix: null == dataFilterSuffix
          ? _value.dataFilterSuffix
          : dataFilterSuffix // ignore: cast_nullable_to_non_nullable
              as String,
      listFilterSuffix: null == listFilterSuffix
          ? _value.listFilterSuffix
          : listFilterSuffix // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$LoaderRepositoryTemplateModelImpl
    implements _LoaderRepositoryTemplateModel {
  const _$LoaderRepositoryTemplateModelImpl(
      {this.dataLoader,
      this.listLoader,
      required this.hasDataLoader,
      required this.hasListLoader,
      required final List<MethodModel> crudMethods,
      required this.repositoryName,
      required this.api,
      required this.dataLoaderMethodName,
      required this.listLoaderMethodName,
      required this.dataFilterSuffix,
      required this.listFilterSuffix})
      : _crudMethods = crudMethods;

  factory _$LoaderRepositoryTemplateModelImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$LoaderRepositoryTemplateModelImplFromJson(json);

  @override
  final LoaderTemplateModel? dataLoader;
  @override
  final LoaderTemplateModel? listLoader;
  @override
  final bool hasDataLoader;
  @override
  final bool hasListLoader;
  final List<MethodModel> _crudMethods;
  @override
  List<MethodModel> get crudMethods {
    if (_crudMethods is EqualUnmodifiableListView) return _crudMethods;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_crudMethods);
  }

  @override
  final String repositoryName;
  @override
  final String api;
  @override
  final String dataLoaderMethodName;
  @override
  final String listLoaderMethodName;
  @override
  final String dataFilterSuffix;
  @override
  final String listFilterSuffix;

  @override
  String toString() {
    return 'LoaderRepositoryTemplateModel(dataLoader: $dataLoader, listLoader: $listLoader, hasDataLoader: $hasDataLoader, hasListLoader: $hasListLoader, crudMethods: $crudMethods, repositoryName: $repositoryName, api: $api, dataLoaderMethodName: $dataLoaderMethodName, listLoaderMethodName: $listLoaderMethodName, dataFilterSuffix: $dataFilterSuffix, listFilterSuffix: $listFilterSuffix)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoaderRepositoryTemplateModelImpl &&
            (identical(other.dataLoader, dataLoader) ||
                other.dataLoader == dataLoader) &&
            (identical(other.listLoader, listLoader) ||
                other.listLoader == listLoader) &&
            (identical(other.hasDataLoader, hasDataLoader) ||
                other.hasDataLoader == hasDataLoader) &&
            (identical(other.hasListLoader, hasListLoader) ||
                other.hasListLoader == hasListLoader) &&
            const DeepCollectionEquality()
                .equals(other._crudMethods, _crudMethods) &&
            (identical(other.repositoryName, repositoryName) ||
                other.repositoryName == repositoryName) &&
            (identical(other.api, api) || other.api == api) &&
            (identical(other.dataLoaderMethodName, dataLoaderMethodName) ||
                other.dataLoaderMethodName == dataLoaderMethodName) &&
            (identical(other.listLoaderMethodName, listLoaderMethodName) ||
                other.listLoaderMethodName == listLoaderMethodName) &&
            (identical(other.dataFilterSuffix, dataFilterSuffix) ||
                other.dataFilterSuffix == dataFilterSuffix) &&
            (identical(other.listFilterSuffix, listFilterSuffix) ||
                other.listFilterSuffix == listFilterSuffix));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      dataLoader,
      listLoader,
      hasDataLoader,
      hasListLoader,
      const DeepCollectionEquality().hash(_crudMethods),
      repositoryName,
      api,
      dataLoaderMethodName,
      listLoaderMethodName,
      dataFilterSuffix,
      listFilterSuffix);

  /// Create a copy of LoaderRepositoryTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LoaderRepositoryTemplateModelImplCopyWith<
          _$LoaderRepositoryTemplateModelImpl>
      get copyWith => __$$LoaderRepositoryTemplateModelImplCopyWithImpl<
          _$LoaderRepositoryTemplateModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LoaderRepositoryTemplateModelImplToJson(
      this,
    );
  }
}

abstract class _LoaderRepositoryTemplateModel
    implements LoaderRepositoryTemplateModel {
  const factory _LoaderRepositoryTemplateModel(
          {final LoaderTemplateModel? dataLoader,
          final LoaderTemplateModel? listLoader,
          required final bool hasDataLoader,
          required final bool hasListLoader,
          required final List<MethodModel> crudMethods,
          required final String repositoryName,
          required final String api,
          required final String dataLoaderMethodName,
          required final String listLoaderMethodName,
          required final String dataFilterSuffix,
          required final String listFilterSuffix}) =
      _$LoaderRepositoryTemplateModelImpl;

  factory _LoaderRepositoryTemplateModel.fromJson(Map<String, dynamic> json) =
      _$LoaderRepositoryTemplateModelImpl.fromJson;

  @override
  LoaderTemplateModel? get dataLoader;
  @override
  LoaderTemplateModel? get listLoader;
  @override
  bool get hasDataLoader;
  @override
  bool get hasListLoader;
  @override
  List<MethodModel> get crudMethods;
  @override
  String get repositoryName;
  @override
  String get api;
  @override
  String get dataLoaderMethodName;
  @override
  String get listLoaderMethodName;
  @override
  String get dataFilterSuffix;
  @override
  String get listFilterSuffix;

  /// Create a copy of LoaderRepositoryTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LoaderRepositoryTemplateModelImplCopyWith<
          _$LoaderRepositoryTemplateModelImpl>
      get copyWith => throw _privateConstructorUsedError;
}

LoaderTemplateModel _$LoaderTemplateModelFromJson(Map<String, dynamic> json) {
  return _LoaderTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$LoaderTemplateModel {
  String get api => throw _privateConstructorUsedError;
  dynamic get hasRequiredParam => throw _privateConstructorUsedError;
  bool get isInline => throw _privateConstructorUsedError;
  bool get shouldUseAsList => throw _privateConstructorUsedError;
  String get methodName => throw _privateConstructorUsedError;
  String get returnType => throw _privateConstructorUsedError;
  String get returnTypeNullabilitySuffix => throw _privateConstructorUsedError;
  bool get hasFilter => throw _privateConstructorUsedError;
  List<ParamModel> get additionalParams => throw _privateConstructorUsedError;
  List<ParamModel> get filterParams => throw _privateConstructorUsedError;

  /// Serializes this LoaderTemplateModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of LoaderTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $LoaderTemplateModelCopyWith<LoaderTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoaderTemplateModelCopyWith<$Res> {
  factory $LoaderTemplateModelCopyWith(
          LoaderTemplateModel value, $Res Function(LoaderTemplateModel) then) =
      _$LoaderTemplateModelCopyWithImpl<$Res, LoaderTemplateModel>;
  @useResult
  $Res call(
      {String api,
      dynamic hasRequiredParam,
      bool isInline,
      bool shouldUseAsList,
      String methodName,
      String returnType,
      String returnTypeNullabilitySuffix,
      bool hasFilter,
      List<ParamModel> additionalParams,
      List<ParamModel> filterParams});
}

/// @nodoc
class _$LoaderTemplateModelCopyWithImpl<$Res, $Val extends LoaderTemplateModel>
    implements $LoaderTemplateModelCopyWith<$Res> {
  _$LoaderTemplateModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of LoaderTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? api = null,
    Object? hasRequiredParam = freezed,
    Object? isInline = null,
    Object? shouldUseAsList = null,
    Object? methodName = null,
    Object? returnType = null,
    Object? returnTypeNullabilitySuffix = null,
    Object? hasFilter = null,
    Object? additionalParams = null,
    Object? filterParams = null,
  }) {
    return _then(_value.copyWith(
      api: null == api
          ? _value.api
          : api // ignore: cast_nullable_to_non_nullable
              as String,
      hasRequiredParam: freezed == hasRequiredParam
          ? _value.hasRequiredParam
          : hasRequiredParam // ignore: cast_nullable_to_non_nullable
              as dynamic,
      isInline: null == isInline
          ? _value.isInline
          : isInline // ignore: cast_nullable_to_non_nullable
              as bool,
      shouldUseAsList: null == shouldUseAsList
          ? _value.shouldUseAsList
          : shouldUseAsList // ignore: cast_nullable_to_non_nullable
              as bool,
      methodName: null == methodName
          ? _value.methodName
          : methodName // ignore: cast_nullable_to_non_nullable
              as String,
      returnType: null == returnType
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      returnTypeNullabilitySuffix: null == returnTypeNullabilitySuffix
          ? _value.returnTypeNullabilitySuffix
          : returnTypeNullabilitySuffix // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: null == hasFilter
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
      additionalParams: null == additionalParams
          ? _value.additionalParams
          : additionalParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
      filterParams: null == filterParams
          ? _value.filterParams
          : filterParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LoaderTemplateModelImplCopyWith<$Res>
    implements $LoaderTemplateModelCopyWith<$Res> {
  factory _$$LoaderTemplateModelImplCopyWith(_$LoaderTemplateModelImpl value,
          $Res Function(_$LoaderTemplateModelImpl) then) =
      __$$LoaderTemplateModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String api,
      dynamic hasRequiredParam,
      bool isInline,
      bool shouldUseAsList,
      String methodName,
      String returnType,
      String returnTypeNullabilitySuffix,
      bool hasFilter,
      List<ParamModel> additionalParams,
      List<ParamModel> filterParams});
}

/// @nodoc
class __$$LoaderTemplateModelImplCopyWithImpl<$Res>
    extends _$LoaderTemplateModelCopyWithImpl<$Res, _$LoaderTemplateModelImpl>
    implements _$$LoaderTemplateModelImplCopyWith<$Res> {
  __$$LoaderTemplateModelImplCopyWithImpl(_$LoaderTemplateModelImpl _value,
      $Res Function(_$LoaderTemplateModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of LoaderTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? api = null,
    Object? hasRequiredParam = freezed,
    Object? isInline = null,
    Object? shouldUseAsList = null,
    Object? methodName = null,
    Object? returnType = null,
    Object? returnTypeNullabilitySuffix = null,
    Object? hasFilter = null,
    Object? additionalParams = null,
    Object? filterParams = null,
  }) {
    return _then(_$LoaderTemplateModelImpl(
      api: null == api
          ? _value.api
          : api // ignore: cast_nullable_to_non_nullable
              as String,
      hasRequiredParam: freezed == hasRequiredParam
          ? _value.hasRequiredParam!
          : hasRequiredParam,
      isInline: null == isInline
          ? _value.isInline
          : isInline // ignore: cast_nullable_to_non_nullable
              as bool,
      shouldUseAsList: null == shouldUseAsList
          ? _value.shouldUseAsList
          : shouldUseAsList // ignore: cast_nullable_to_non_nullable
              as bool,
      methodName: null == methodName
          ? _value.methodName
          : methodName // ignore: cast_nullable_to_non_nullable
              as String,
      returnType: null == returnType
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      returnTypeNullabilitySuffix: null == returnTypeNullabilitySuffix
          ? _value.returnTypeNullabilitySuffix
          : returnTypeNullabilitySuffix // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: null == hasFilter
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
      additionalParams: null == additionalParams
          ? _value._additionalParams
          : additionalParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
      filterParams: null == filterParams
          ? _value._filterParams
          : filterParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$LoaderTemplateModelImpl implements _LoaderTemplateModel {
  const _$LoaderTemplateModelImpl(
      {required this.api,
      this.hasRequiredParam = false,
      this.isInline = false,
      this.shouldUseAsList = false,
      required this.methodName,
      required this.returnType,
      required this.returnTypeNullabilitySuffix,
      this.hasFilter = false,
      final List<ParamModel> additionalParams = const [],
      final List<ParamModel> filterParams = const []})
      : _additionalParams = additionalParams,
        _filterParams = filterParams;

  factory _$LoaderTemplateModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$LoaderTemplateModelImplFromJson(json);

  @override
  final String api;
  @override
  @JsonKey()
  final dynamic hasRequiredParam;
  @override
  @JsonKey()
  final bool isInline;
  @override
  @JsonKey()
  final bool shouldUseAsList;
  @override
  final String methodName;
  @override
  final String returnType;
  @override
  final String returnTypeNullabilitySuffix;
  @override
  @JsonKey()
  final bool hasFilter;
  final List<ParamModel> _additionalParams;
  @override
  @JsonKey()
  List<ParamModel> get additionalParams {
    if (_additionalParams is EqualUnmodifiableListView)
      return _additionalParams;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_additionalParams);
  }

  final List<ParamModel> _filterParams;
  @override
  @JsonKey()
  List<ParamModel> get filterParams {
    if (_filterParams is EqualUnmodifiableListView) return _filterParams;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_filterParams);
  }

  @override
  String toString() {
    return 'LoaderTemplateModel(api: $api, hasRequiredParam: $hasRequiredParam, isInline: $isInline, shouldUseAsList: $shouldUseAsList, methodName: $methodName, returnType: $returnType, returnTypeNullabilitySuffix: $returnTypeNullabilitySuffix, hasFilter: $hasFilter, additionalParams: $additionalParams, filterParams: $filterParams)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoaderTemplateModelImpl &&
            (identical(other.api, api) || other.api == api) &&
            const DeepCollectionEquality()
                .equals(other.hasRequiredParam, hasRequiredParam) &&
            (identical(other.isInline, isInline) ||
                other.isInline == isInline) &&
            (identical(other.shouldUseAsList, shouldUseAsList) ||
                other.shouldUseAsList == shouldUseAsList) &&
            (identical(other.methodName, methodName) ||
                other.methodName == methodName) &&
            (identical(other.returnType, returnType) ||
                other.returnType == returnType) &&
            (identical(other.returnTypeNullabilitySuffix,
                    returnTypeNullabilitySuffix) ||
                other.returnTypeNullabilitySuffix ==
                    returnTypeNullabilitySuffix) &&
            (identical(other.hasFilter, hasFilter) ||
                other.hasFilter == hasFilter) &&
            const DeepCollectionEquality()
                .equals(other._additionalParams, _additionalParams) &&
            const DeepCollectionEquality()
                .equals(other._filterParams, _filterParams));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      api,
      const DeepCollectionEquality().hash(hasRequiredParam),
      isInline,
      shouldUseAsList,
      methodName,
      returnType,
      returnTypeNullabilitySuffix,
      hasFilter,
      const DeepCollectionEquality().hash(_additionalParams),
      const DeepCollectionEquality().hash(_filterParams));

  /// Create a copy of LoaderTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LoaderTemplateModelImplCopyWith<_$LoaderTemplateModelImpl> get copyWith =>
      __$$LoaderTemplateModelImplCopyWithImpl<_$LoaderTemplateModelImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LoaderTemplateModelImplToJson(
      this,
    );
  }
}

abstract class _LoaderTemplateModel implements LoaderTemplateModel {
  const factory _LoaderTemplateModel(
      {required final String api,
      final dynamic hasRequiredParam,
      final bool isInline,
      final bool shouldUseAsList,
      required final String methodName,
      required final String returnType,
      required final String returnTypeNullabilitySuffix,
      final bool hasFilter,
      final List<ParamModel> additionalParams,
      final List<ParamModel> filterParams}) = _$LoaderTemplateModelImpl;

  factory _LoaderTemplateModel.fromJson(Map<String, dynamic> json) =
      _$LoaderTemplateModelImpl.fromJson;

  @override
  String get api;
  @override
  dynamic get hasRequiredParam;
  @override
  bool get isInline;
  @override
  bool get shouldUseAsList;
  @override
  String get methodName;
  @override
  String get returnType;
  @override
  String get returnTypeNullabilitySuffix;
  @override
  bool get hasFilter;
  @override
  List<ParamModel> get additionalParams;
  @override
  List<ParamModel> get filterParams;

  /// Create a copy of LoaderTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LoaderTemplateModelImplCopyWith<_$LoaderTemplateModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CubitTemplateModel _$CubitTemplateModelFromJson(Map<String, dynamic> json) {
  return _CubitTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$CubitTemplateModel {
  String get name => throw _privateConstructorUsedError;
  String get returnType => throw _privateConstructorUsedError;
  bool get hasFilter => throw _privateConstructorUsedError;
  List<MethodModel> get crudMethods => throw _privateConstructorUsedError;
  String get filterSuffix => throw _privateConstructorUsedError;
  String get loaderMethodName => throw _privateConstructorUsedError;
  String? get blocMixins => throw _privateConstructorUsedError;
  bool get hasBlocMixins => throw _privateConstructorUsedError;

  /// Serializes this CubitTemplateModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CubitTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CubitTemplateModelCopyWith<CubitTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CubitTemplateModelCopyWith<$Res> {
  factory $CubitTemplateModelCopyWith(
          CubitTemplateModel value, $Res Function(CubitTemplateModel) then) =
      _$CubitTemplateModelCopyWithImpl<$Res, CubitTemplateModel>;
  @useResult
  $Res call(
      {String name,
      String returnType,
      bool hasFilter,
      List<MethodModel> crudMethods,
      String filterSuffix,
      String loaderMethodName,
      String? blocMixins,
      bool hasBlocMixins});
}

/// @nodoc
class _$CubitTemplateModelCopyWithImpl<$Res, $Val extends CubitTemplateModel>
    implements $CubitTemplateModelCopyWith<$Res> {
  _$CubitTemplateModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CubitTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? returnType = null,
    Object? hasFilter = null,
    Object? crudMethods = null,
    Object? filterSuffix = null,
    Object? loaderMethodName = null,
    Object? blocMixins = freezed,
    Object? hasBlocMixins = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      returnType: null == returnType
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: null == hasFilter
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
      crudMethods: null == crudMethods
          ? _value.crudMethods
          : crudMethods // ignore: cast_nullable_to_non_nullable
              as List<MethodModel>,
      filterSuffix: null == filterSuffix
          ? _value.filterSuffix
          : filterSuffix // ignore: cast_nullable_to_non_nullable
              as String,
      loaderMethodName: null == loaderMethodName
          ? _value.loaderMethodName
          : loaderMethodName // ignore: cast_nullable_to_non_nullable
              as String,
      blocMixins: freezed == blocMixins
          ? _value.blocMixins
          : blocMixins // ignore: cast_nullable_to_non_nullable
              as String?,
      hasBlocMixins: null == hasBlocMixins
          ? _value.hasBlocMixins
          : hasBlocMixins // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CubitTemplateModelImplCopyWith<$Res>
    implements $CubitTemplateModelCopyWith<$Res> {
  factory _$$CubitTemplateModelImplCopyWith(_$CubitTemplateModelImpl value,
          $Res Function(_$CubitTemplateModelImpl) then) =
      __$$CubitTemplateModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String name,
      String returnType,
      bool hasFilter,
      List<MethodModel> crudMethods,
      String filterSuffix,
      String loaderMethodName,
      String? blocMixins,
      bool hasBlocMixins});
}

/// @nodoc
class __$$CubitTemplateModelImplCopyWithImpl<$Res>
    extends _$CubitTemplateModelCopyWithImpl<$Res, _$CubitTemplateModelImpl>
    implements _$$CubitTemplateModelImplCopyWith<$Res> {
  __$$CubitTemplateModelImplCopyWithImpl(_$CubitTemplateModelImpl _value,
      $Res Function(_$CubitTemplateModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of CubitTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? returnType = null,
    Object? hasFilter = null,
    Object? crudMethods = null,
    Object? filterSuffix = null,
    Object? loaderMethodName = null,
    Object? blocMixins = freezed,
    Object? hasBlocMixins = null,
  }) {
    return _then(_$CubitTemplateModelImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      returnType: null == returnType
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: null == hasFilter
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
      crudMethods: null == crudMethods
          ? _value._crudMethods
          : crudMethods // ignore: cast_nullable_to_non_nullable
              as List<MethodModel>,
      filterSuffix: null == filterSuffix
          ? _value.filterSuffix
          : filterSuffix // ignore: cast_nullable_to_non_nullable
              as String,
      loaderMethodName: null == loaderMethodName
          ? _value.loaderMethodName
          : loaderMethodName // ignore: cast_nullable_to_non_nullable
              as String,
      blocMixins: freezed == blocMixins
          ? _value.blocMixins
          : blocMixins // ignore: cast_nullable_to_non_nullable
              as String?,
      hasBlocMixins: null == hasBlocMixins
          ? _value.hasBlocMixins
          : hasBlocMixins // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$CubitTemplateModelImpl implements _CubitTemplateModel {
  const _$CubitTemplateModelImpl(
      {required this.name,
      required this.returnType,
      this.hasFilter = false,
      required final List<MethodModel> crudMethods,
      required this.filterSuffix,
      required this.loaderMethodName,
      this.blocMixins,
      this.hasBlocMixins = false})
      : _crudMethods = crudMethods;

  factory _$CubitTemplateModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$CubitTemplateModelImplFromJson(json);

  @override
  final String name;
  @override
  final String returnType;
  @override
  @JsonKey()
  final bool hasFilter;
  final List<MethodModel> _crudMethods;
  @override
  List<MethodModel> get crudMethods {
    if (_crudMethods is EqualUnmodifiableListView) return _crudMethods;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_crudMethods);
  }

  @override
  final String filterSuffix;
  @override
  final String loaderMethodName;
  @override
  final String? blocMixins;
  @override
  @JsonKey()
  final bool hasBlocMixins;

  @override
  String toString() {
    return 'CubitTemplateModel(name: $name, returnType: $returnType, hasFilter: $hasFilter, crudMethods: $crudMethods, filterSuffix: $filterSuffix, loaderMethodName: $loaderMethodName, blocMixins: $blocMixins, hasBlocMixins: $hasBlocMixins)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CubitTemplateModelImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.returnType, returnType) ||
                other.returnType == returnType) &&
            (identical(other.hasFilter, hasFilter) ||
                other.hasFilter == hasFilter) &&
            const DeepCollectionEquality()
                .equals(other._crudMethods, _crudMethods) &&
            (identical(other.filterSuffix, filterSuffix) ||
                other.filterSuffix == filterSuffix) &&
            (identical(other.loaderMethodName, loaderMethodName) ||
                other.loaderMethodName == loaderMethodName) &&
            (identical(other.blocMixins, blocMixins) ||
                other.blocMixins == blocMixins) &&
            (identical(other.hasBlocMixins, hasBlocMixins) ||
                other.hasBlocMixins == hasBlocMixins));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      name,
      returnType,
      hasFilter,
      const DeepCollectionEquality().hash(_crudMethods),
      filterSuffix,
      loaderMethodName,
      blocMixins,
      hasBlocMixins);

  /// Create a copy of CubitTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CubitTemplateModelImplCopyWith<_$CubitTemplateModelImpl> get copyWith =>
      __$$CubitTemplateModelImplCopyWithImpl<_$CubitTemplateModelImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CubitTemplateModelImplToJson(
      this,
    );
  }
}

abstract class _CubitTemplateModel implements CubitTemplateModel {
  const factory _CubitTemplateModel(
      {required final String name,
      required final String returnType,
      final bool hasFilter,
      required final List<MethodModel> crudMethods,
      required final String filterSuffix,
      required final String loaderMethodName,
      final String? blocMixins,
      final bool hasBlocMixins}) = _$CubitTemplateModelImpl;

  factory _CubitTemplateModel.fromJson(Map<String, dynamic> json) =
      _$CubitTemplateModelImpl.fromJson;

  @override
  String get name;
  @override
  String get returnType;
  @override
  bool get hasFilter;
  @override
  List<MethodModel> get crudMethods;
  @override
  String get filterSuffix;
  @override
  String get loaderMethodName;
  @override
  String? get blocMixins;
  @override
  bool get hasBlocMixins;

  /// Create a copy of CubitTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CubitTemplateModelImplCopyWith<_$CubitTemplateModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

BuiltListJsonConverterModel _$BuiltListJsonConverterModelFromJson(
    Map<String, dynamic> json) {
  return _BuiltListJsonConverterModel.fromJson(json);
}

/// @nodoc
mixin _$BuiltListJsonConverterModel {
  String get converterName => throw _privateConstructorUsedError;
  String get innerReturnType => throw _privateConstructorUsedError;
  bool get shouldCreateConverter => throw _privateConstructorUsedError;

  /// Serializes this BuiltListJsonConverterModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of BuiltListJsonConverterModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $BuiltListJsonConverterModelCopyWith<BuiltListJsonConverterModel>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BuiltListJsonConverterModelCopyWith<$Res> {
  factory $BuiltListJsonConverterModelCopyWith(
          BuiltListJsonConverterModel value,
          $Res Function(BuiltListJsonConverterModel) then) =
      _$BuiltListJsonConverterModelCopyWithImpl<$Res,
          BuiltListJsonConverterModel>;
  @useResult
  $Res call(
      {String converterName,
      String innerReturnType,
      bool shouldCreateConverter});
}

/// @nodoc
class _$BuiltListJsonConverterModelCopyWithImpl<$Res,
        $Val extends BuiltListJsonConverterModel>
    implements $BuiltListJsonConverterModelCopyWith<$Res> {
  _$BuiltListJsonConverterModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BuiltListJsonConverterModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? converterName = null,
    Object? innerReturnType = null,
    Object? shouldCreateConverter = null,
  }) {
    return _then(_value.copyWith(
      converterName: null == converterName
          ? _value.converterName
          : converterName // ignore: cast_nullable_to_non_nullable
              as String,
      innerReturnType: null == innerReturnType
          ? _value.innerReturnType
          : innerReturnType // ignore: cast_nullable_to_non_nullable
              as String,
      shouldCreateConverter: null == shouldCreateConverter
          ? _value.shouldCreateConverter
          : shouldCreateConverter // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BuiltListJsonConverterModelImplCopyWith<$Res>
    implements $BuiltListJsonConverterModelCopyWith<$Res> {
  factory _$$BuiltListJsonConverterModelImplCopyWith(
          _$BuiltListJsonConverterModelImpl value,
          $Res Function(_$BuiltListJsonConverterModelImpl) then) =
      __$$BuiltListJsonConverterModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String converterName,
      String innerReturnType,
      bool shouldCreateConverter});
}

/// @nodoc
class __$$BuiltListJsonConverterModelImplCopyWithImpl<$Res>
    extends _$BuiltListJsonConverterModelCopyWithImpl<$Res,
        _$BuiltListJsonConverterModelImpl>
    implements _$$BuiltListJsonConverterModelImplCopyWith<$Res> {
  __$$BuiltListJsonConverterModelImplCopyWithImpl(
      _$BuiltListJsonConverterModelImpl _value,
      $Res Function(_$BuiltListJsonConverterModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of BuiltListJsonConverterModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? converterName = null,
    Object? innerReturnType = null,
    Object? shouldCreateConverter = null,
  }) {
    return _then(_$BuiltListJsonConverterModelImpl(
      converterName: null == converterName
          ? _value.converterName
          : converterName // ignore: cast_nullable_to_non_nullable
              as String,
      innerReturnType: null == innerReturnType
          ? _value.innerReturnType
          : innerReturnType // ignore: cast_nullable_to_non_nullable
              as String,
      shouldCreateConverter: null == shouldCreateConverter
          ? _value.shouldCreateConverter
          : shouldCreateConverter // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$BuiltListJsonConverterModelImpl
    implements _BuiltListJsonConverterModel {
  const _$BuiltListJsonConverterModelImpl(
      {required this.converterName,
      required this.innerReturnType,
      this.shouldCreateConverter = true});

  factory _$BuiltListJsonConverterModelImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$BuiltListJsonConverterModelImplFromJson(json);

  @override
  final String converterName;
  @override
  final String innerReturnType;
  @override
  @JsonKey()
  final bool shouldCreateConverter;

  @override
  String toString() {
    return 'BuiltListJsonConverterModel(converterName: $converterName, innerReturnType: $innerReturnType, shouldCreateConverter: $shouldCreateConverter)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BuiltListJsonConverterModelImpl &&
            (identical(other.converterName, converterName) ||
                other.converterName == converterName) &&
            (identical(other.innerReturnType, innerReturnType) ||
                other.innerReturnType == innerReturnType) &&
            (identical(other.shouldCreateConverter, shouldCreateConverter) ||
                other.shouldCreateConverter == shouldCreateConverter));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, converterName, innerReturnType, shouldCreateConverter);

  /// Create a copy of BuiltListJsonConverterModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BuiltListJsonConverterModelImplCopyWith<_$BuiltListJsonConverterModelImpl>
      get copyWith => __$$BuiltListJsonConverterModelImplCopyWithImpl<
          _$BuiltListJsonConverterModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$BuiltListJsonConverterModelImplToJson(
      this,
    );
  }
}

abstract class _BuiltListJsonConverterModel
    implements BuiltListJsonConverterModel {
  const factory _BuiltListJsonConverterModel(
      {required final String converterName,
      required final String innerReturnType,
      final bool shouldCreateConverter}) = _$BuiltListJsonConverterModelImpl;

  factory _BuiltListJsonConverterModel.fromJson(Map<String, dynamic> json) =
      _$BuiltListJsonConverterModelImpl.fromJson;

  @override
  String get converterName;
  @override
  String get innerReturnType;
  @override
  bool get shouldCreateConverter;

  /// Create a copy of BuiltListJsonConverterModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BuiltListJsonConverterModelImplCopyWith<_$BuiltListJsonConverterModelImpl>
      get copyWith => throw _privateConstructorUsedError;
}

BuiltListJsonConverterTemplateModel
    _$BuiltListJsonConverterTemplateModelFromJson(Map<String, dynamic> json) {
  return _BuiltListJsonConverterTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$BuiltListJsonConverterTemplateModel {
  String get converterName => throw _privateConstructorUsedError;
  String get innerReturnType => throw _privateConstructorUsedError;

  /// Serializes this BuiltListJsonConverterTemplateModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of BuiltListJsonConverterTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $BuiltListJsonConverterTemplateModelCopyWith<
          BuiltListJsonConverterTemplateModel>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BuiltListJsonConverterTemplateModelCopyWith<$Res> {
  factory $BuiltListJsonConverterTemplateModelCopyWith(
          BuiltListJsonConverterTemplateModel value,
          $Res Function(BuiltListJsonConverterTemplateModel) then) =
      _$BuiltListJsonConverterTemplateModelCopyWithImpl<$Res,
          BuiltListJsonConverterTemplateModel>;
  @useResult
  $Res call({String converterName, String innerReturnType});
}

/// @nodoc
class _$BuiltListJsonConverterTemplateModelCopyWithImpl<$Res,
        $Val extends BuiltListJsonConverterTemplateModel>
    implements $BuiltListJsonConverterTemplateModelCopyWith<$Res> {
  _$BuiltListJsonConverterTemplateModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BuiltListJsonConverterTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? converterName = null,
    Object? innerReturnType = null,
  }) {
    return _then(_value.copyWith(
      converterName: null == converterName
          ? _value.converterName
          : converterName // ignore: cast_nullable_to_non_nullable
              as String,
      innerReturnType: null == innerReturnType
          ? _value.innerReturnType
          : innerReturnType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BuiltListJsonConverterTemplateModelImplCopyWith<$Res>
    implements $BuiltListJsonConverterTemplateModelCopyWith<$Res> {
  factory _$$BuiltListJsonConverterTemplateModelImplCopyWith(
          _$BuiltListJsonConverterTemplateModelImpl value,
          $Res Function(_$BuiltListJsonConverterTemplateModelImpl) then) =
      __$$BuiltListJsonConverterTemplateModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String converterName, String innerReturnType});
}

/// @nodoc
class __$$BuiltListJsonConverterTemplateModelImplCopyWithImpl<$Res>
    extends _$BuiltListJsonConverterTemplateModelCopyWithImpl<$Res,
        _$BuiltListJsonConverterTemplateModelImpl>
    implements _$$BuiltListJsonConverterTemplateModelImplCopyWith<$Res> {
  __$$BuiltListJsonConverterTemplateModelImplCopyWithImpl(
      _$BuiltListJsonConverterTemplateModelImpl _value,
      $Res Function(_$BuiltListJsonConverterTemplateModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of BuiltListJsonConverterTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? converterName = null,
    Object? innerReturnType = null,
  }) {
    return _then(_$BuiltListJsonConverterTemplateModelImpl(
      converterName: null == converterName
          ? _value.converterName
          : converterName // ignore: cast_nullable_to_non_nullable
              as String,
      innerReturnType: null == innerReturnType
          ? _value.innerReturnType
          : innerReturnType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$BuiltListJsonConverterTemplateModelImpl
    implements _BuiltListJsonConverterTemplateModel {
  const _$BuiltListJsonConverterTemplateModelImpl(
      {required this.converterName, required this.innerReturnType});

  factory _$BuiltListJsonConverterTemplateModelImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$BuiltListJsonConverterTemplateModelImplFromJson(json);

  @override
  final String converterName;
  @override
  final String innerReturnType;

  @override
  String toString() {
    return 'BuiltListJsonConverterTemplateModel(converterName: $converterName, innerReturnType: $innerReturnType)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BuiltListJsonConverterTemplateModelImpl &&
            (identical(other.converterName, converterName) ||
                other.converterName == converterName) &&
            (identical(other.innerReturnType, innerReturnType) ||
                other.innerReturnType == innerReturnType));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, converterName, innerReturnType);

  /// Create a copy of BuiltListJsonConverterTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BuiltListJsonConverterTemplateModelImplCopyWith<
          _$BuiltListJsonConverterTemplateModelImpl>
      get copyWith => __$$BuiltListJsonConverterTemplateModelImplCopyWithImpl<
          _$BuiltListJsonConverterTemplateModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$BuiltListJsonConverterTemplateModelImplToJson(
      this,
    );
  }
}

abstract class _BuiltListJsonConverterTemplateModel
    implements BuiltListJsonConverterTemplateModel {
  const factory _BuiltListJsonConverterTemplateModel(
          {required final String converterName,
          required final String innerReturnType}) =
      _$BuiltListJsonConverterTemplateModelImpl;

  factory _BuiltListJsonConverterTemplateModel.fromJson(
          Map<String, dynamic> json) =
      _$BuiltListJsonConverterTemplateModelImpl.fromJson;

  @override
  String get converterName;
  @override
  String get innerReturnType;

  /// Create a copy of BuiltListJsonConverterTemplateModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BuiltListJsonConverterTemplateModelImplCopyWith<
          _$BuiltListJsonConverterTemplateModelImpl>
      get copyWith => throw _privateConstructorUsedError;
}
